export function trieRootToITrieRoot(root) {
    return ImplITrieRoot.toITrieNode(root);
}
export function trieNodeToITrieNode(node) {
    return ImplITrieNode.toITrieNode(node);
}
const EmptyKeys = Object.freeze([]);
const EmptyValues = Object.freeze([]);
const EmptyEntries = Object.freeze([]);
class ImplITrieNode {
    node;
    id;
    _keys;
    constructor(node) {
        this.node = node;
        this.id = node;
    }
    /** flag End of Word */
    get eow() {
        return !!this.node.f;
    }
    /** number of children */
    get size() {
        if (!this.node.c)
            return 0;
        return this.keys().length;
    }
    /** get keys to children */
    keys() {
        if (this._keys)
            return this._keys;
        const keys = this.node.c ? Object.keys(this.node.c) : EmptyKeys;
        this._keys = keys;
        return keys;
    }
    /** get the child nodes */
    values() {
        return !this.node.c ? EmptyValues : Object.values(this.node.c).map((n) => ImplITrieNode.toITrieNode(n));
    }
    entries() {
        return !this.node.c
            ? EmptyEntries
            : Object.entries(this.node.c).map(([k, n]) => [k, ImplITrieNode.toITrieNode(n)]);
    }
    /** get child ITrieNode */
    get(char) {
        const n = this.node.c?.[char];
        if (!n)
            return undefined;
        return ImplITrieNode.toITrieNode(n);
    }
    getNode(chars) {
        return this.findNode(chars);
    }
    has(char) {
        const c = this.node.c;
        return (c && char in c) || false;
    }
    child(keyIdx) {
        const char = this.keys()[keyIdx];
        const n = char && this.get(char);
        if (!n)
            throw new Error('Index out of range.');
        return n;
    }
    hasChildren() {
        return !!this.node.c;
    }
    #findTrieNode(word) {
        let node = this.node;
        for (const char of word) {
            if (!node)
                return undefined;
            node = node.c?.[char];
        }
        return node;
    }
    findNode(word) {
        const node = this.#findTrieNode(word);
        return node && ImplITrieNode.toITrieNode(node);
    }
    findExact(word) {
        const node = this.#findTrieNode(word);
        return !!node && !!node.f;
    }
    static toITrieNode(node) {
        return new this(node);
    }
}
class ImplITrieRoot extends ImplITrieNode {
    root;
    info;
    hasForbiddenWords;
    hasCompoundWords;
    hasNonStrictWords;
    constructor(root) {
        super(root);
        this.root = root;
        const { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware } = root;
        this.info = { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware };
        this.hasForbiddenWords = !!root.c[forbiddenWordPrefix];
        this.hasCompoundWords = !!root.c[compoundCharacter];
        this.hasNonStrictWords = !!root.c[stripCaseAndAccentsPrefix];
    }
    get eow() {
        return false;
    }
    resolveId(id) {
        const n = id;
        return new ImplITrieNode(n);
    }
    get forbidPrefix() {
        return this.root.forbiddenWordPrefix;
    }
    get compoundFix() {
        return this.root.compoundCharacter;
    }
    get caseInsensitivePrefix() {
        return this.root.stripCaseAndAccentsPrefix;
    }
    static toITrieNode(node) {
        return new this(node);
    }
}
//# sourceMappingURL=trie.js.map