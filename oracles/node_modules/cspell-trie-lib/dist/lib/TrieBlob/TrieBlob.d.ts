import type { FindResult, ITrieNode, ITrieNodeRoot } from '../ITrieNode/ITrieNode.js';
import type { PartialTrieInfo, TrieInfo } from '../ITrieNode/TrieInfo.js';
import type { TrieData } from '../TrieData.js';
import { CharIndex, Utf8Seq } from './CharIndex.js';
export declare class TrieBlob implements TrieData {
    #private;
    protected nodes: Uint32Array;
    readonly charIndex: CharIndex;
    readonly info: Readonly<TrieInfo>;
    readonly wordToCharacters: (word: string) => string[];
    readonly hasForbiddenWords: boolean;
    readonly hasCompoundWords: boolean;
    readonly hasNonStrictWords: boolean;
    constructor(nodes: Uint32Array, charIndex: CharIndex, info: PartialTrieInfo);
    wordToUtf8Seq(word: string): Utf8Seq;
    private letterToNodeCharIndexSequence;
    has(word: string): boolean;
    isForbiddenWord(word: string): boolean;
    /**
     * Try to find the word in the trie. The word must be normalized.
     * If `strict` is `true` the case and accents must match.
     * Compound words are supported assuming that the compound character is in the trie.
     *
     * @param word - the word to find (normalized)
     * @param strict - if `true` the case and accents must match.
     */
    find(word: string, strict: boolean): FindResult | undefined;
    getRoot(): ITrieNodeRoot;
    private _getRoot;
    getNode(prefix: string): ITrieNode | undefined;
    /**
     * Find the node index for the given character.
     * @param nodeIdx - node index to start the search
     * @param char - character to look for
     * @returns
     */
    private _lookupNode;
    words(): Iterable<string>;
    get size(): number;
    toJSON(): {
        options: Readonly<TrieInfo>;
        nodes: NodeElement[];
        charIndex: CharIndex;
    };
    encodeBin(): Uint8Array;
    static decodeBin(blob: Uint8Array): TrieBlob;
    static NodeMaskEOW: number;
    static NodeMaskNumChildren: number;
    static NodeMaskNumChildrenShift: number;
    static NodeChildRefShift: number;
    /**
     * Only 8 bits are reserved for the character index.
     * The max index is {@link TrieBlob.SpecialCharIndexMask} - 1.
     * Node chaining is used to reference higher character indexes.
     * - @see {@link TrieBlob.SpecialCharIndexMask}
     * - @see {@link TrieBlob.MaxCharIndex}
     */
    static NodeMaskChildCharIndex: number;
    static nodesView(trie: TrieBlob): Readonly<Uint32Array>;
}
interface NodeElement {
    id: number;
    eow: boolean;
    c: {
        c: number | string;
        o: number;
    }[];
    n: number;
}
export {};
//# sourceMappingURL=TrieBlob.d.ts.map