/** A utf8 value represented as big endian 32bit number */
export type Utf8BE32 = number;
/** A utf8 value represented as little endian 32bit number */
export type Utf8LE32 = number;
export type CodePoint = number;
/**
 * Encode a CodePoint into a Big Endian utf8 value, up to 4 bytes.
 * These numbers sort into the correct order for utf8.
 *
 *            hightest byte           lowest byte   Code Point Range
 * - 1 byte:  00000000 00000000 00000000 0xxxxxxx - 0x0000_0000 - 0x0000_007f
 * - 2 bytes: 00000000 00000000 110xxxxx 10xxxxxx - 0x0000_0080 - 0x0000_07ff
 * - 3 bytes: 00000000 1110xxxx 10xxxxxx 10xxxxxx - 0x0000_0800 - 0x0000_ffff
 * - 4 bytes: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx - 0x0001_0000 - 0x001f_ffff
 *
 * @param code - the code point to encode
 * @returns number containing the utf8 value.
 */
export declare function encodeUtf8N_BE(code: CodePoint): Utf8BE32;
export declare function decodeUtf8N_BE(utf8: Utf8BE32): CodePoint;
/**
 * Encode a CodePoint into a Little Endian utf8 value, up to 4 bytes.
 *
 * These numbers DO NOT sort into the correct order for utf8.
 *
 *            hightest byte           lowest byte   Code Point Range
 * - 1 byte:  00000000 00000000 00000000 0xxxxxxx - 0x0000_0000 - 0x0000_007f
 * - 2 bytes: 00000000 00000000 10xxxxxx 110xxxxx - 0x0000_0080 - 0x0000_07ff
 * - 3 bytes: 00000000 10xxxxxx 10xxxxxx 1110xxxx - 0x0000_0800 - 0x0000_ffff
 * - 4 bytes: 10xxxxxx 10xxxxxx 10xxxxxx 11110xxx - 0x0001_0000 - 0x001f_ffff
 *
 * @param code - the code point to encode
 * @returns number containing the utf8 value.
 */
export declare function encodeUtf8N_LE(code: CodePoint): Utf8LE32;
export declare function decodeUtf8N_LE(utf8: Utf8LE32): CodePoint;
export declare class Utf8Accumulator {
    remaining: number;
    value: number;
    decode(byte: number): CodePoint | undefined;
    reset(): number;
    clone(into?: Utf8Accumulator): Utf8Accumulator;
    static isMultiByte(v: number): boolean;
    static isSingleByte(v: number): boolean;
    static create(): Utf8Accumulator;
}
export declare function decodeUtf8ByteStream(bytes: Iterable<number> | ReadonlyArray<number> | Uint8Array): Iterable<CodePoint>;
export declare function decodeUtf8ByteArray(bytes: ReadonlyArray<number> | Uint8Array): CodePoint[];
export declare function encodeUtf8into(code: CodePoint, into: Array<number> | Uint8Array, offset?: number): number;
export declare function encodeTextToUtf8Into(text: string, into: Array<number> | Uint8Array, offset?: number): number;
export declare function encodeTextToUtf8(text: string): number[];
export declare function textToCodePoints(text: string): CodePoint[];
export declare function encodeCodePointsToUtf8Into(data: CodePoint[], into: Array<number> | Uint8Array, offset?: number): number;
export declare function hex32(n: number): string;
//# sourceMappingURL=Utf8.d.ts.map