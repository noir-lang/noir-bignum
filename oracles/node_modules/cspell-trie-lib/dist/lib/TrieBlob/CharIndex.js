import { encodeTextToUtf8, encodeUtf8N_BE } from './Utf8.js';
const emptySeq = [0];
Object.freeze(emptySeq);
export class CharIndex {
    charIndex;
    #charToUtf8SeqMap;
    #lastWord = '';
    #lastWordSeq = [];
    #multiByteChars;
    constructor(charIndex) {
        this.charIndex = charIndex;
        this.#charToUtf8SeqMap = buildCharIndexSequenceMap(charIndex);
        this.#multiByteChars = [...this.#charToUtf8SeqMap.values()].some((c) => c.length > 1);
    }
    getCharUtf8Seq(c) {
        const found = this.#charToUtf8SeqMap.get(c);
        if (found)
            return found;
        const s = encodeTextToUtf8(c);
        this.#charToUtf8SeqMap.set(c, s);
        return s;
    }
    wordToUtf8Seq(word) {
        if (this.#lastWord === word)
            return this.#lastWordSeq;
        const seq = encodeTextToUtf8(word);
        this.#lastWord = word;
        this.#lastWordSeq = seq;
        return seq;
    }
    indexContainsMultiByteChars() {
        return this.#multiByteChars;
    }
    get size() {
        return this.charIndex.length;
    }
    toJSON() {
        return { charIndex: this.charIndex };
    }
}
function buildCharIndexSequenceMap(charIndex) {
    const map = new Map();
    for (const key of charIndex) {
        map.set(key, encodeTextToUtf8(key));
    }
    return map;
}
export class CharIndexBuilder {
    charIndex = [];
    charIndexMap = new Map();
    charIndexSeqMap = new Map();
    #mapIdxToSeq = new Map();
    constructor() {
        this.getUtf8Value('');
    }
    getUtf8Value(c) {
        const found = this.charIndexMap.get(c);
        if (found !== undefined) {
            return found;
        }
        const nc = c.normalize('NFC');
        this.charIndex.push(nc);
        const utf8 = encodeUtf8N_BE(nc.codePointAt(0) || 0);
        this.charIndexMap.set(c, utf8);
        this.charIndexMap.set(nc, utf8);
        this.charIndexMap.set(c.normalize('NFD'), utf8);
        return utf8;
    }
    utf8ValueToUtf8Seq(idx) {
        const found = this.#mapIdxToSeq.get(idx);
        if (found !== undefined) {
            return found;
        }
        const seq = splitUtf8(idx);
        this.#mapIdxToSeq.set(idx, seq);
        return seq;
    }
    charToUtf8Seq(c) {
        const idx = this.getUtf8Value(c);
        return this.utf8ValueToUtf8Seq(idx);
    }
    wordToUtf8Seq(word) {
        const seq = new Array(word.length);
        let i = 0;
        for (const c of word) {
            const idx = this.getUtf8Value(c);
            const cSep = this.utf8ValueToUtf8Seq(idx);
            if (typeof cSep === 'number') {
                seq[i++] = cSep;
                continue;
            }
            for (const cIdx of cSep) {
                seq[i++] = cIdx;
            }
        }
        if (seq.length !== i)
            seq.length = i;
        return seq;
    }
    get size() {
        return this.charIndex.length;
    }
    build() {
        return new CharIndex(this.charIndex);
    }
}
function splitUtf8(utf8) {
    if (utf8 <= 0xff)
        return [utf8];
    if (utf8 <= 0xffff)
        return [(utf8 >> 8) & 0xff, utf8 & 0xff];
    if (utf8 <= 0xff_ffff)
        return [(utf8 >> 16) & 0xff, (utf8 >> 8) & 0xff, utf8 & 0xff];
    return [(utf8 >> 24) & 0xff, (utf8 >> 16) & 0xff, (utf8 >> 8) & 0xff, utf8 & 0xff].filter((v) => v);
}
//# sourceMappingURL=CharIndex.js.map