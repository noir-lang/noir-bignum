export function startTimer() {
    const start = performance.now();
    return () => performance.now() - start;
}
export function measure(name, fn, log = console.log) {
    const calcElapsed = startTimer();
    const r = fn();
    const elapsed = (' '.repeat(16) + `${calcElapsed().toFixed(3)}ms.`).slice(-16);
    log(`${name} ${elapsed}`);
    return r;
}
export async function measureAsync(name, fn, log = console.log) {
    const calcElapsed = startTimer();
    const r = await fn();
    const elapsed = (' '.repeat(16) + `${calcElapsed().toFixed(3)}ms.`).slice(-16);
    log(`${name} ${elapsed}`);
    return r;
}
export function createPerfTimer() {
    const timer = startTimer();
    const active = new Map();
    const events = [{ name: 'start', at: 0 }];
    function updateEvent(event, atTime = timer()) {
        const elapsed = atTime - event.at;
        event.elapsed = (event.elapsed || 0) + elapsed;
        return elapsed;
    }
    function start(name) {
        const event = createEvent(name || 'start');
        events.push(event);
        name && active.set(name, event);
        return () => updateEvent(event);
    }
    function stop(name) {
        const knownEvent = name && active.get(name);
        if (knownEvent) {
            return updateEvent(knownEvent);
        }
        return mark(name || 'stop');
    }
    function createEvent(name) {
        return { name, at: timer() };
    }
    function mark(name) {
        const event = createEvent(name);
        events.push(event);
        return event.at;
    }
    function formatReport() {
        const lineElements = [
            { name: 'Event Name', at: 'Time', elapsed: 'Elapsed' },
            { name: '----------', at: '----', elapsed: '-------' },
            ...mapEvents(),
        ];
        function mapEvents() {
            const stack = [];
            return events.map((e) => {
                for (let s = stack.pop(); s; s = stack.pop()) {
                    if (s >= e.at + (e.elapsed || 0)) {
                        stack.push(s);
                        break;
                    }
                }
                const d = stack.length;
                if (e.elapsed) {
                    stack.push(e.at + e.elapsed);
                }
                return {
                    name: '| '.repeat(d) + (e.name || '').replaceAll('\t', '  '),
                    at: `${t(e.at)}`,
                    elapsed: e.elapsed ? `${t(e.elapsed)}` : '--',
                };
            });
        }
        function t(ms) {
            return ms.toFixed(3) + 'ms';
        }
        function m(v, s) {
            return Math.max(v, s.length);
        }
        const lengths = lineElements.reduce((a, b) => ({ name: m(a.name, b.name), at: m(a.at, b.at), elapsed: m(a.elapsed, b.elapsed) }), { name: 0, at: 0, elapsed: 0 });
        const lines = lineElements.map((e) => `${e.at.padStart(lengths.at)}  ${e.name.padEnd(lengths.name)}  ${e.elapsed.padStart(lengths.elapsed)}`);
        return lines.join('\n');
    }
    function measureFn(name, fn) {
        const s = start(name);
        const v = fn();
        s();
        return v;
    }
    async function measureAsyncFn(name, fn) {
        const s = start(name);
        const v = await fn();
        s();
        return v;
    }
    function report(reporter = console.log) {
        reporter(formatReport());
    }
    return {
        start,
        stop,
        mark,
        elapsed: timer,
        report,
        formatReport,
        measureFn,
        measureAsyncFn,
    };
}
let globalPerfTimer = undefined;
export function getGlobalPerfTimer() {
    const timer = globalPerfTimer || createPerfTimer();
    globalPerfTimer = timer;
    return timer;
}
//# sourceMappingURL=timer.js.map