import { walker, walkerWords } from './walker/walker.js';
export function isWordTerminationNode(node) {
    return node.eow;
}
/**
 * Generator an iterator that will walk the Trie parent then children in a depth first fashion that preserves sorted order.
 */
export function walk(node) {
    return walker(node);
}
export const iterateTrie = walk;
/**
 * Generate a Iterator that can walk a Trie and yield the words.
 */
export function iteratorTrieWords(node) {
    return walkerWords(node);
}
export function has(node, word) {
    const n = findNode(node, word);
    return (n && n.eow) || false;
}
export function findNode(node, word) {
    for (let i = 0; i < word.length; ++i) {
        const n = node.get(word[i]);
        if (!n)
            return undefined;
        node = n;
    }
    return node;
}
export function countNodes(root) {
    const seen = new Set();
    function walk(n) {
        if (seen.has(n.id))
            return;
        seen.add(n.id);
        for (const c of n.values()) {
            walk(c);
        }
    }
    walk(root);
    return seen.size;
}
export function countWords(root) {
    const visited = new Map();
    function walk(n) {
        const nestedCount = visited.get(n.id);
        if (nestedCount !== undefined) {
            return nestedCount;
        }
        let cnt = n.eow ? 1 : 0;
        // add the node to the set to avoid getting stuck on circular references.
        visited.set(n, cnt);
        for (const c of n.values()) {
            cnt += walk(c);
        }
        visited.set(n, cnt);
        return cnt;
    }
    return walk(root);
}
//# sourceMappingURL=trie-util.js.map