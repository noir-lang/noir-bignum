import { memorizeLastCall } from '../utils/memorizeLastCall.js';
const defaultLegacyMinCompoundLength = 3;
const _defaultFindOptions = {
    matchCase: false,
    compoundMode: 'compound',
    legacyMinCompoundLength: defaultLegacyMinCompoundLength,
};
Object.freeze(_defaultFindOptions);
const arrayCompoundModes = ['none', 'compound', 'legacy'];
const knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
const notFound = { found: false, compoundUsed: false, caseMatched: false, forbidden: undefined };
Object.freeze(notFound);
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
export function findWordNode(root, word, options) {
    return _findWordNode(root, word, options);
}
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
export function findWord(root, word, options) {
    if (root.find) {
        const found = root.find(word, options?.matchCase || false);
        if (found)
            return found;
        if (!root.hasCompoundWords) {
            return notFound;
        }
    }
    // return { found: false, compoundUsed: false, caseMatched: false, forbidden: false };
    const v = _findWordNode(root, word, options);
    return {
        found: v.found,
        compoundUsed: v.compoundUsed,
        caseMatched: v.caseMatched,
        forbidden: v.forbidden,
    };
}
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
function _findWordNode(root, word, options) {
    const trieInfo = root.info;
    const matchCase = options?.matchCase || false;
    const compoundMode = knownCompoundModes.get(options?.compoundMode) || _defaultFindOptions.compoundMode;
    const compoundPrefix = compoundMode === 'compound' ? (trieInfo.compoundCharacter ?? root.compoundFix) : '';
    const ignoreCasePrefix = matchCase ? '' : (trieInfo.stripCaseAndAccentsPrefix ?? root.caseInsensitivePrefix);
    const checkForbidden = options?.checkForbidden ?? true;
    function __findCompound() {
        const f = findCompoundWord(root, word, compoundPrefix, ignoreCasePrefix);
        const result = { ...f };
        if (f.found !== false && f.compoundUsed) {
            // If case was ignored when searching for the word, then check the forbidden
            // in the ignore case forbidden list.
            const r = !f.caseMatched ? walk(root, root.caseInsensitivePrefix) : root;
            result.forbidden = checkForbidden ? isForbiddenWord(r, word, root.forbidPrefix) : undefined;
        }
        return result;
    }
    function __findExact() {
        const n = root.getNode ? root.getNode(word) : walk(root, word);
        const isFound = isEndOfWordNode(n);
        const result = {
            found: isFound && word,
            compoundUsed: false,
            forbidden: checkForbidden ? isForbiddenWord(root, word, root.forbidPrefix) : undefined,
            node: n,
            caseMatched: true,
        };
        return result;
    }
    switch (compoundMode) {
        case 'none': {
            return matchCase ? __findExact() : __findCompound();
        }
        case 'compound': {
            return __findCompound();
        }
        case 'legacy': {
            return findLegacyCompound(root, word, options);
        }
    }
}
export function findLegacyCompound(root, word, options) {
    const roots = [root];
    if (!options?.matchCase) {
        roots.push(walk(root, root.caseInsensitivePrefix));
    }
    return findLegacyCompoundNode(roots, word, options?.legacyMinCompoundLength || defaultLegacyMinCompoundLength);
}
export function findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix) {
    // Approach - do a depth first search for the matching word.
    const stack = [
        // { n: root, compoundPrefix: '', cr: undefined, caseMatched: true },
        { n: root, compoundPrefix: ignoreCasePrefix, cr: undefined, caseMatched: true },
    ];
    const compoundPrefix = compoundCharacter || ignoreCasePrefix;
    const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : '';
    const nw = word.normalize();
    const w = [...nw];
    function determineRoot(s) {
        const prefix = s.compoundPrefix;
        let r = root;
        let i;
        for (i = 0; i < prefix.length && r; ++i) {
            r = r.get(prefix[i]);
        }
        const caseMatched = s.caseMatched && prefix[0] !== ignoreCasePrefix;
        return {
            n: s.n,
            compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : '',
            cr: r,
            caseMatched,
        };
    }
    let compoundUsed = false;
    let caseMatched = true;
    let i = 0;
    let node;
    while (true) {
        const s = stack[i];
        const h = w[i++];
        const n = s.cr || s.n;
        const c = (h && n?.get(h)) || undefined;
        if (c && i < word.length) {
            // Go deeper.
            caseMatched = s.caseMatched;
            stack[i] = { n: c, compoundPrefix, cr: undefined, caseMatched };
        }
        else if (!c || !c.eow) {
            // Remember the first matching node for possible auto completion.
            node = node || c;
            // We did not find the word backup and take the first unused compound branch
            while (--i > 0) {
                const s = stack[i];
                if (!s.compoundPrefix || !s.n?.hasChildren())
                    continue;
                if (s.n.get(compoundCharacter))
                    break;
            }
            if (i >= 0 && stack[i].compoundPrefix) {
                compoundUsed = i > 0;
                const r = determineRoot(stack[i]);
                stack[i] = r;
                if (!r.cr) {
                    break;
                }
                if (!i && !r.caseMatched && nw !== nw.toLowerCase()) {
                    // It is not going to be found.
                    break;
                }
            }
            else {
                break;
            }
        }
        else {
            node = c;
            caseMatched = s.caseMatched;
            break;
        }
    }
    const found = (i === word.length && word) || false;
    const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
    return result;
}
function findCompoundWord(root, word, compoundCharacter, ignoreCasePrefix) {
    const { found, compoundUsed, node, caseMatched } = findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix);
    // Was it a word?
    if (!node || !node.eow) {
        // not found.
        return { found: false, compoundUsed, node, forbidden: undefined, caseMatched };
    }
    return { found, compoundUsed, node, forbidden: undefined, caseMatched };
}
export function findWordExact(root, word) {
    const r = root;
    if (r?.findExact)
        return r.findExact(word);
    return isEndOfWordNode(walk(root, word));
}
export function isEndOfWordNode(n) {
    return !!n?.eow;
}
function walk(root, word) {
    const w = [...word];
    let n = root;
    let i = 0;
    while (n && i < w.length) {
        const h = w[i++];
        n = n.get(h);
    }
    return n;
}
function findLegacyCompoundNode(roots, word, minCompoundLength) {
    const root = roots[0];
    const numRoots = roots.length;
    // Approach - do a depth first search for the matching word.
    const stack = [
        { n: root, usedRoots: 1, subLength: 0, isCompound: false, cr: undefined, caseMatched: true },
    ];
    const w = word;
    const wLen = w.length;
    let compoundUsed = false;
    let caseMatched = true;
    let i = 0;
    let node;
    while (true) {
        const s = stack[i];
        const h = w[i++];
        const n = s.cr || s.n;
        const c = n?.get(h);
        if (c && i < wLen) {
            // Go deeper.
            stack[i] = {
                n: c,
                usedRoots: 0,
                subLength: s.subLength + 1,
                isCompound: s.isCompound,
                cr: undefined,
                caseMatched: s.caseMatched,
            };
        }
        else if (!c || !c.eow || (c.eow && s.subLength < minCompoundLength - 1)) {
            // We did not find the word backup and take the first unused compound branch
            while (--i > 0) {
                const s = stack[i];
                if (s.usedRoots < numRoots &&
                    s.n?.eow &&
                    (s.subLength >= minCompoundLength || !s.subLength) &&
                    wLen - i >= minCompoundLength) {
                    break;
                }
            }
            if (i > 0 || stack[i].usedRoots < numRoots) {
                compoundUsed = i > 0;
                const s = stack[i];
                s.cr = roots[s.usedRoots++];
                s.subLength = 0;
                s.isCompound = compoundUsed;
                s.caseMatched = s.caseMatched && s.usedRoots <= 1;
            }
            else {
                break;
            }
        }
        else {
            node = c;
            caseMatched = s.caseMatched;
            break;
        }
    }
    function extractWord() {
        if (!word || i < word.length)
            return false;
        const letters = [];
        let subLen = 0;
        for (let j = 0; j < i; ++j) {
            const { subLength } = stack[j];
            if (subLength < subLen) {
                letters.push('+');
            }
            letters.push(word[j]);
            subLen = subLength;
        }
        return letters.join('');
    }
    const found = extractWord();
    const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
    return result;
}
function findLegacyCompoundWord(roots, word, minCompoundLength) {
    const { found, compoundUsed, caseMatched } = findLegacyCompoundNode(roots, word, minCompoundLength);
    return { found, compoundUsed, caseMatched };
}
export function isForbiddenWord(root, word, forbiddenPrefix) {
    const r = root;
    if (r?.isForbidden)
        return r.isForbidden(word);
    return findWordExact(root?.get(forbiddenPrefix), word);
}
export const createFindOptions = memorizeLastCall(_createFindOptions);
function _createFindOptions(options) {
    if (!options)
        return _defaultFindOptions;
    const d = _defaultFindOptions;
    return {
        matchCase: options.matchCase ?? d.matchCase,
        compoundMode: options.compoundMode ?? d.compoundMode,
        legacyMinCompoundLength: options.legacyMinCompoundLength ?? d.legacyMinCompoundLength,
        checkForbidden: options.checkForbidden ?? d.checkForbidden,
    };
}
export const __testing__ = {
    findLegacyCompoundWord,
};
//# sourceMappingURL=find.js.map