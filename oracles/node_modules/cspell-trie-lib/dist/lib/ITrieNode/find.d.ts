import type { FindOptions, PartialFindOptions } from './FindOptions.js';
import type { FindFullNodeResult } from './FindTypes.js';
import type { FindFullResult, FindResult, ITrieNode, ITrieNodeRoot } from './ITrieNode.js';
type Root = ITrieNodeRoot;
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
export declare function findWordNode(root: Root, word: string, options?: PartialFindOptions): FindFullNodeResult;
/**
 *
 * @param root Trie root node. root.c contains the compound root and forbidden root.
 * @param word A pre normalized word use `normalizeWord` or `normalizeWordToLowercase`
 * @param options
 */
export declare function findWord(root: Root, word: string, options?: PartialFindOptions): FindFullResult;
export declare function findLegacyCompound(root: Root, word: string, options: PartialFindOptions): FindFullNodeResult;
export declare function findCompoundNode(root: Root | undefined, word: string, compoundCharacter: string, ignoreCasePrefix: string): FindFullNodeResult;
export declare function findWordExact(root: Root | ITrieNode | undefined, word: string): boolean;
export declare function isEndOfWordNode(n: ITrieNode | undefined): boolean;
declare function findLegacyCompoundWord(roots: (ITrieNode | undefined)[], word: string, minCompoundLength: number): FindResult;
export declare function isForbiddenWord(root: Root | ITrieNode | undefined, word: string, forbiddenPrefix: string): boolean;
export declare const createFindOptions: (p: PartialFindOptions) => FindOptions;
export declare const __testing__: {
    findLegacyCompoundWord: typeof findLegacyCompoundWord;
};
export {};
//# sourceMappingURL=find.d.ts.map