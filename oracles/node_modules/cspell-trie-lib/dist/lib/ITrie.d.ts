import type { WeightMap } from './distance/index.js';
import type { ITrieNode } from './ITrieNode/index.js';
import { FindFullResult } from './ITrieNode/ITrieNode.js';
import type { PartialTrieInfo, TrieInfo } from './ITrieNode/TrieInfo.js';
import type { CompoundWordsMethod, WalkerIterator } from './ITrieNode/walker/walkerTypes.js';
import type { SuggestionCollector, SuggestionResult } from './suggestCollector.js';
import { type SuggestionOptions } from './suggestions/genSuggestionsOptions.js';
import type { TrieData } from './TrieData.js';
export interface ITrie {
    readonly data: TrieData;
    /**
     * Approximate number of words in the Trie, the first call to this method might be expensive.
     * Use `size` to get the number of nodes.
     *
     * It does NOT count natural compound words. Natural compounds are words that are composed of appending
     * multiple words to make a new word. This is common in languages like German and Dutch.
     */
    numWords(): number;
    /**
     * Used to check if the number of words has been calculated.
     */
    isNumWordsKnown(): boolean;
    /**
     * The number of nodes in the Trie. There is a rough corelation between the size and the number of words.
     */
    readonly size: number;
    readonly info: Readonly<TrieInfo>;
    /**
     * @param text - text to find in the Trie
     */
    find(text: string): ITrieNode | undefined;
    has(word: string): boolean;
    has(word: string, minLegacyCompoundLength: boolean | number): boolean;
    /**
     * Determine if a word is in the dictionary.
     * @param word - the exact word to search for - must be normalized.
     * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
     * @returns true if the word was found and is not forbidden.
     */
    hasWord(word: string, caseSensitive: boolean): boolean;
    findWord(word: string, options?: FindWordOptions): FindFullResult;
    /**
     * Determine if a word is in the forbidden word list.
     * @param word the word to lookup.
     */
    isForbiddenWord(word: string): boolean;
    /**
     * Provides an ordered sequence of words with the prefix of text.
     */
    completeWord(text: string): Iterable<string>;
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * @param text - the text to search for
     * @param options - Controls the generated suggestions:
     * - ignoreCase - Ignore Case and Accents
     * - numSuggestions - the maximum number of suggestions to return.
     * - compoundMethod - Use to control splitting words.
     * - changeLimit - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
     *                      the lower the value, the faster results are returned. Values less than 4 are best.
     */
    suggest(text: string, options: SuggestionOptions): string[];
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
     */
    suggestWithCost(text: string, options: SuggestionOptions): SuggestionResult[];
    /**
     * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
     * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
     * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
     */
    genSuggestions(collector: SuggestionCollector, compoundMethod?: CompoundWordsMethod): void;
    /**
     * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
     */
    words(): Iterable<string>;
    /**
     * Allows iteration over the entire tree.
     * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
     */
    iterate(): WalkerIterator;
    readonly weightMap: WeightMap | undefined;
    readonly isCaseAware: boolean;
    readonly hasForbiddenWords: boolean;
    readonly hasCompoundWords: boolean;
    readonly hasNonStrictWords: boolean;
}
export declare class ITrieImpl implements ITrie {
    #private;
    readonly data: TrieData;
    private numNodes?;
    private _info;
    private root;
    private count?;
    weightMap: WeightMap | undefined;
    readonly hasForbiddenWords: boolean;
    readonly hasCompoundWords: boolean;
    readonly hasNonStrictWords: boolean;
    constructor(data: TrieData, numNodes?: number | undefined);
    /**
     * Number of words in the Trie, the first call to this method might be expensive.
     * Use `size` to get the number of nodes.
     */
    numWords(): number;
    isNumWordsKnown(): boolean;
    get size(): number;
    get info(): Readonly<TrieInfo>;
    get isCaseAware(): boolean;
    /**
     * @param text - text to find in the Trie
     */
    find(text: string): ITrieNode | undefined;
    has(word: string, minLegacyCompoundLength?: boolean | number): boolean;
    /**
     * Determine if a word is in the dictionary.
     * @param word - the exact word to search for - must be normalized.
     * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
     * @returns true if the word was found and is not forbidden.
     */
    hasWord(word: string, caseSensitive: boolean): boolean;
    findWord(word: string, options?: FindWordOptions): FindFullResult;
    /**
     * Determine if a word is in the forbidden word list.
     * @param word the word to lookup.
     */
    isForbiddenWord(word: string): boolean;
    /**
     * Provides an ordered sequence of words with the prefix of text.
     */
    completeWord(text: string): Iterable<string>;
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * @param text - the text to search for
     * @param maxNumSuggestions - the maximum number of suggestions to return.
     * @param compoundMethod - Use to control splitting words.
     * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
     *                      the lower the value, the faster results are returned. Values less than 4 are best.
     */
    suggest(text: string, options: SuggestionOptions): string[];
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
     */
    suggestWithCost(text: string, options: SuggestionOptions): SuggestionResult[];
    /**
     * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
     * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
     * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
     */
    genSuggestions(collector: SuggestionCollector, compoundMethod?: CompoundWordsMethod): void;
    /**
     * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
     */
    words(): Iterable<string>;
    /**
     * Allows iteration over the entire tree.
     * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
     */
    iterate(): WalkerIterator;
    static create(words: Iterable<string> | IterableIterator<string>, info?: PartialTrieInfo): ITrie;
    private createFindOptions;
}
export interface FindWordOptions {
    caseSensitive?: boolean;
    useLegacyWordCompounds?: boolean | number;
    checkForbidden?: boolean;
}
//# sourceMappingURL=ITrie.d.ts.map