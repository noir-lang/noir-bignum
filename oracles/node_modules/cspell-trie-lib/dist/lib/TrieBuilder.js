import { consolidate } from './consolidate.js';
import { Trie } from './trie.js';
import { checkCircular, createTrieRootFromList, trieNodeToRoot } from './TrieNode/trie-util.js';
import { mergeOptionalWithDefaults } from './utils/mergeOptionalWithDefaults.js';
import { SecondChanceCache } from './utils/secondChanceCache.js';
const SymbolFrozenNode = Symbol();
/**
 * Builds an optimized Trie from a Iterable<string>. It attempts to reduce the size of the trie
 * by finding common endings.
 * @param words Iterable set of words -- no processing is done on the words, they are inserted as is.
 * @param trieOptions options for the Trie
 */
export function buildTrie(words, trieOptions) {
    return new TrieBuilder(words, trieOptions).build();
}
/**
 * Builds a Trie from a Iterable<string>. NO attempt a reducing the size of the Trie is done.
 * @param words Iterable set of words -- no processing is done on the words, they are inserted as is.
 * @param trieOptions options for the Trie
 */
export function buildTrieFast(words, trieOptions) {
    const root = createTrieRootFromList(words, trieOptions);
    return new Trie(root, undefined);
}
// cspell:words sigs
const MAX_NUM_SIGS = 100_000;
const MAX_TRANSFORMS = 1_000_000;
const MAX_CACHE_SIZE = 1_000_000;
export class TrieBuilder {
    count = 0;
    signatures = new SecondChanceCache(MAX_NUM_SIGS);
    cached = new SecondChanceCache(MAX_CACHE_SIZE);
    transforms = new SecondChanceCache(MAX_TRANSFORMS);
    _eow;
    /** position 0 of lastPath is always the root */
    lastPath = [{ s: '', n: { id: 0, f: undefined, c: undefined } }];
    tails = new Map();
    trieOptions;
    numWords = 0;
    _debug_lastWordsInserted = [];
    // private _debug_mode = true;
    _debug_mode = false;
    constructor(words, trieOptions) {
        this._eow = this.createNodeFrozen(1);
        this.tails.set('', this._eow);
        this._canBeCached(this._eow); // this line is just for coverage reasons
        this.signatures.set(this.signature(this._eow), this._eow);
        this.cached.set(this._eow, this._eow.id ?? ++this.count);
        this.trieOptions = Object.freeze(mergeOptionalWithDefaults(trieOptions));
        if (words) {
            this.insert(words);
        }
    }
    get _root() {
        return trieNodeToRoot(this.lastPath[0].n, this.trieOptions);
    }
    signature(n) {
        const isWord = n.f ? '*' : '';
        const entries = n.c ? Object.entries(n.c) : undefined;
        const c = entries ? entries.map(([k, n]) => [k, this.cached.get(n)]) : undefined;
        const ref = c ? JSON.stringify(c) : '';
        const sig = isWord + ref;
        return sig;
    }
    _canBeCached(n) {
        if (!n.c)
            return true;
        for (const v of Object.values(n.c)) {
            if (!this.cached.has(v))
                return false;
        }
        return true;
    }
    tryCacheFrozen(n) {
        assertFrozen(n);
        if (this.cached.has(n)) {
            return n;
        }
        this.cached.set(n, n.id ?? ++this.count);
        return n;
    }
    freeze(n) {
        if (Object.isFrozen(n))
            return n;
        // istanbul ignore else
        if (n.c) {
            const c = Object.entries(n.c)
                .sort((a, b) => (a[0] < b[0] ? -1 : 1))
                .map(([k, n]) => [k, this.freeze(n)]);
            n.c = Object.fromEntries(c);
            Object.freeze(n.c);
        }
        return Object.freeze(n);
    }
    tryToCache(n) {
        if (!this._canBeCached(n)) {
            return n;
        }
        const sig = this.signature(n);
        const ref = this.signatures.get(sig);
        if (ref !== undefined) {
            return this.tryCacheFrozen(ref);
        }
        this.signatures.set(sig, this.freeze(n));
        return n;
    }
    storeTransform(src, s, result) {
        if (!Object.isFrozen(result) || !Object.isFrozen(src))
            return;
        this.logDebug('storeTransform', () => ({ s, src: this.debNodeInfo(src), result: this.debNodeInfo(result) }));
        const t = this.transforms.get(src) ?? new Map();
        t.set(s, result);
        this.transforms.set(src, t);
    }
    addChild(node, head, child) {
        if (node.c?.[head] !== child) {
            let c = node.c || Object.create(null);
            if (Object.isFrozen(c)) {
                c = Object.assign(Object.create(null), c);
            }
            c[head] = child;
            if (Object.isFrozen(node)) {
                node = this.createNode(node.f, c);
            }
            else {
                node.c = c;
            }
        }
        return Object.isFrozen(child) ? this.tryToCache(node) : node;
    }
    buildTail(s) {
        const ss = s.join('');
        const v = this.tails.get(ss);
        if (v)
            return v;
        const head = s[0];
        const tail = s.slice(1);
        const t = this.tails.get(tail.join(''));
        const c = t || this.buildTail(tail);
        const n = this.addChild(this.createNode(), head, c);
        if (!t) {
            return n;
        }
        const cachedNode = this.tryCacheFrozen(this.freeze(n));
        this.tails.set(ss, cachedNode);
        // console.warn('tail: %s', s);
        return cachedNode;
    }
    _insert(node, s, d) {
        this.logDebug('_insert', () => ({
            n: this.debNodeInfo(node),
            s,
            d,
            w: this.lastPath.map((a) => a.s).join(''),
        }));
        const orig = node;
        if (Object.isFrozen(node)) {
            const n = this.transforms.get(node)?.get(s.join(''));
            if (n) {
                return this.tryCacheFrozen(n);
            }
        }
        if (!s.length) {
            if (!node.c) {
                return this._eow;
            }
            else {
                node = this.copyIfFrozen(node);
                node.f = this._eow.f;
                return node;
            }
        }
        const head = s[0];
        const tail = s.slice(1);
        const cNode = node.c?.[head];
        const child = cNode ? this._insert(cNode, tail, d + 1) : this.buildTail(tail);
        node = this.addChild(node, head, child);
        this.storeTransform(orig, s.join(''), node);
        this.lastPath[d] = { s: head, n: child };
        return node;
    }
    insertWord(word) {
        // this._debug_mode ||= this.numWords >= 26123525;
        this.logDebug('insertWord', word);
        this._debug_lastWordsInserted[this.numWords & 0xf] = word;
        this.numWords++;
        // if (!(this.numWords % 100000) /*|| this.numWords > 26123530 */) {
        //     console.warn('check circular at: %o', this.numWords);
        //     const check = checkCircular(this._root);
        //     if (check.isCircular) {
        //         const prevWord = this.lastPath.map((a) => a.s).join('|');
        //         const prevWords = this._debug_lastWordsInserted.map(
        //             (w, i) => this._debug_lastWordsInserted[(this.numWords + i) & 0xf],
        //         );
        //         const { word, pos, stack } = check.ref;
        //         console.error('Circular before %o\ncheck: %o', this.numWords, { word, pos, prevWord, prevWords });
        //         console.error('Stack: %o', this.debugStack(stack));
        //         throw new Error('Circular');
        //     }
        // }
        const chars = [...word];
        let d = 1;
        for (const s of chars) {
            const p = this.lastPath[d];
            if (p?.s !== s)
                break;
            d++;
        }
        // remove the remaining part of the path because it doesn't match this word.
        if (chars.length < d) {
            d = chars.length;
        }
        this.lastPath.length = d;
        d -= 1;
        const { n } = this.lastPath[d];
        const tail = chars.slice(d);
        this.lastPath[d].n = this._insert(n, tail, d + 1);
        while (d > 0) {
            const { s, n } = this.lastPath[d];
            d -= 1;
            const parent = this.lastPath[d];
            const pn = parent.n;
            parent.n = this.addChild(pn, s, n);
            if (pn === parent.n)
                break;
            const tail = chars.slice(d);
            this.storeTransform(pn, tail.join(''), parent.n);
        }
    }
    insert(words) {
        for (const w of words) {
            w && this.insertWord(w);
        }
    }
    /**
     * Resets the builder
     */
    reset() {
        this.lastPath = [{ s: '', n: { id: 0, f: undefined, c: undefined } }];
        this.cached.clear();
        this.signatures.clear();
        this.signatures.set(this.signature(this._eow), this._eow);
        this.count = 0;
        this.cached.set(this._eow, this._eow.id ?? ++this.count);
    }
    build(consolidateSuffixes = false) {
        const root = this._root;
        // Reset the builder to prevent updating the trie in the background.
        this.reset();
        const check = checkCircular(this._root);
        if (check.isCircular) {
            const { word, pos } = check.ref;
            console.error('Circular Reference %o', { word, pos });
            throw new Error('Trie: Circular Reference');
        }
        return new Trie(consolidateSuffixes ? consolidate(root) : root);
    }
    debugStack(stack) {
        return stack.map((n) => this.debNodeInfo(n));
    }
    debNodeInfo(node) {
        const id = node.id ?? '?';
        const cid = this.cached.get(node) ?? '?';
        const f = node.f || 0;
        const c = node.c
            ? Object.fromEntries(Object.entries(node.c).map(([k, n]) => [k, { id: n.id, r: this.cached.get(n) }]))
            : undefined;
        const L = Object.isFrozen(node);
        return { id, cid, f, c, L };
    }
    logDebug(methodName, contentOrFunction) {
        this.runDebug(() => {
            const content = typeof contentOrFunction === 'function' ? contentOrFunction() : contentOrFunction;
            console.warn('%s: %o', methodName, content);
        });
    }
    runDebug(method) {
        if (this._debug_mode) {
            method();
        }
    }
    copyIfFrozen(n) {
        if (!Object.isFrozen(n))
            return n;
        const c = n.c ? Object.assign(Object.create(null), n.c) : undefined;
        return this.createNode(n.f, c);
    }
    createNodeFrozen(f, c) {
        return this.freeze(this.createNode(f, c));
    }
    createNode(f, c) {
        return { id: ++this.count, f, c };
    }
}
function assertFrozen(n) {
    if (!('id' in n)) {
        console.warn('%o', n);
    }
    if (!Object.isFrozen(n) || !('id' in n))
        throw new Error('Must be TrieNodeExFrozen');
}
//# sourceMappingURL=TrieBuilder.js.map