import type { BufferEncoding } from '../models/BufferEncoding.js';
import type { FileReference, FileResourceRequest, UrlOrReference } from '../models/FileResource.js';
export declare class CFileReference implements FileReference {
    readonly url: URL;
    readonly encoding: BufferEncoding | undefined;
    readonly baseFilename: string | undefined;
    /**
     * Use to ensure the nominal type separation between CFileReference and FileReference
     * See: https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal
     */
    private _?;
    readonly gz: boolean | undefined;
    constructor(url: URL, encoding: BufferEncoding | undefined, baseFilename: string | undefined, gz: boolean | undefined);
    static isCFileReference(obj: unknown): obj is CFileReference;
    static from(fileReference: FileReference): CFileReference;
    static from(url: URL, encoding?: BufferEncoding, baseFilename?: string | undefined, gz?: boolean | undefined): CFileReference;
    toJson(): {
        url: string;
        encoding: BufferEncoding | undefined;
        baseFilename: string | undefined;
        gz: boolean | undefined;
    };
}
/**
 *
 * @param file - a URL, file path, or FileReference
 * @param encoding - optional encoding used to decode the file.
 * @param baseFilename - optional base filename used with data URLs.
 * @param gz - optional flag to indicate if the file is gzipped.
 * @returns a FileReference
 */
export declare function toFileReference(file: UrlOrReference, encoding?: BufferEncoding, baseFilename?: string, gz?: boolean | undefined): FileReference;
export declare function isFileReference(ref: UrlOrReference): ref is FileReference;
export declare function renameFileReference(ref: FileReference, newUrl: URL): FileReference;
export declare function toFileResourceRequest(file: UrlOrReference, encoding?: BufferEncoding, signal?: AbortSignal): FileResourceRequest;
//# sourceMappingURL=CFileReference.d.ts.map