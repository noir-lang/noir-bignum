import { urlOrReferenceToUrl } from './common/index.js';
import { getDefaultCSpellIO } from './CSpellIONode.js';
import { debug } from './VirtualFS.js';
import { CVFileSystem } from './VirtualFS/CVFileSystem.js';
import { chopUrl, cspellIOToFsProvider, CVfsDirEntry, rPad, VFSErrorUnsupportedRequest, WrappedProviderFs, } from './VirtualFS/WrappedProviderFs.js';
class CVirtualFS {
    providers = new Set();
    cachedFs = new Map();
    revCacheFs = new Map();
    fsc;
    fs;
    loggingEnabled = debug;
    constructor() {
        this.fsc = fsPassThroughCore((url) => this._getFS(url));
        this.fs = new CVFileSystem(this.fsc);
    }
    enableLogging(value) {
        this.loggingEnabled = value ?? true;
    }
    log = console.log;
    logEvent = (event) => {
        if (this.loggingEnabled) {
            const id = event.traceID.toFixed(13).replaceAll(/\d{4}(?=\d)/g, '$&.');
            const msg = event.message ? `\n\t\t${event.message}` : '';
            const method = rPad(`${event.method}-${event.event}`, 16);
            this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
        }
    };
    registerFileSystemProvider(...providers) {
        providers.forEach((provider) => this.providers.add(provider));
        this.reset();
        return {
            dispose: () => {
                for (const provider of providers) {
                    for (const key of this.revCacheFs.get(provider) || []) {
                        this.cachedFs.delete(key);
                    }
                    this.providers.delete(provider) && undefined;
                }
                this.reset();
            },
        };
    }
    getFS(url) {
        return new CVFileSystem(this._getFS(url));
    }
    _getFS(url) {
        const key = `${url.protocol}${url.hostname}`;
        const cached = this.cachedFs.get(key);
        if (cached) {
            return cached;
        }
        const fnNext = (provider, next) => {
            return (url) => {
                let calledNext = false;
                const fs = provider.getFileSystem(url, (_url) => {
                    calledNext = calledNext || url === _url;
                    return next(_url);
                });
                if (fs) {
                    const s = this.revCacheFs.get(provider) || new Set();
                    s.add(key);
                    this.revCacheFs.set(provider, s);
                    return fs;
                }
                if (!calledNext) {
                    return next(url);
                }
                return undefined;
            };
        };
        let next = (_url) => undefined;
        for (const provider of this.providers) {
            next = fnNext(provider, next);
        }
        const fs = new WrappedProviderFs(next(url), this.logEvent);
        this.cachedFs.set(key, fs);
        return fs;
    }
    reset() {
        this.disposeOfCachedFs();
    }
    disposeOfCachedFs() {
        for (const [key, fs] of [...this.cachedFs].reverse()) {
            try {
                WrappedProviderFs.disposeOf(fs);
            }
            catch {
                // continue - we are cleaning up.
            }
            this.cachedFs.delete(key);
        }
        this.cachedFs.clear();
        this.revCacheFs.clear();
    }
    dispose() {
        this.disposeOfCachedFs();
        const providers = [...this.providers].reverse();
        for (const provider of providers) {
            try {
                provider.dispose?.();
            }
            catch {
                // continue - we are cleaning up.
            }
        }
    }
}
function fsPassThroughCore(fs) {
    function gfs(ur, name) {
        const url = urlOrReferenceToUrl(ur);
        const f = fs(url);
        if (!f.hasProvider)
            throw new VFSErrorUnsupportedRequest(name, url, ur instanceof URL ? undefined : { url: ur.url.toString(), encoding: ur.encoding });
        return f;
    }
    return {
        providerInfo: { name: 'default' },
        hasProvider: true,
        stat: async (url) => gfs(url, 'stat').stat(url),
        readFile: async (url, options) => gfs(url, 'readFile').readFile(url, options),
        writeFile: async (file) => gfs(file, 'writeFile').writeFile(file),
        readDirectory: async (url) => gfs(url, 'readDirectory')
            .readDirectory(url)
            .then((entries) => entries.map((e) => new CVfsDirEntry(e))),
        getCapabilities: (url) => gfs(url, 'getCapabilities').getCapabilities(url),
    };
}
export function createVirtualFS(cspellIO) {
    const cspell = cspellIO || getDefaultCSpellIO();
    const vfs = new CVirtualFS();
    vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell));
    return vfs;
}
let defaultVirtualFs = undefined;
export function getDefaultVirtualFs() {
    if (!defaultVirtualFs) {
        defaultVirtualFs = createVirtualFS();
    }
    return defaultVirtualFs;
}
export function getDefaultVFileSystemCore() {
    return getDefaultVirtualFs().fsc;
}
export function getDefaultVFileSystem() {
    return getDefaultVirtualFs().fs;
}
//# sourceMappingURL=CVirtualFS.js.map