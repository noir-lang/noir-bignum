import { isServiceResponseSuccess, ServiceBus } from '@cspell/cspell-service-bus';
import { isFileReference, toFileReference, toFileResourceRequest } from './common/CFileReference.js';
import { CFileResource } from './common/CFileResource.js';
import { compareStats } from './common/stat.js';
import { toReadFileOptions } from './CSpellIO.js';
import { ErrorNotImplemented } from './errors/errors.js';
import { registerHandlers } from './handlers/node/file.js';
import { toFileURL, toURL, urlBasename, urlDirname } from './node/file/url.js';
import { RequestFsReadFile, RequestFsReadFileSync, RequestFsStat, RequestFsStatSync, RequestFsWriteFile, } from './requests/index.js';
import { RequestFsReadDirectory } from './requests/RequestFsReadDirectory.js';
let defaultCSpellIONode = undefined;
export class CSpellIONode {
    serviceBus;
    constructor(serviceBus = new ServiceBus()) {
        this.serviceBus = serviceBus;
        registerHandlers(serviceBus);
    }
    readFile(urlOrFilename, options) {
        const readOptions = toReadFileOptions(options);
        const ref = toFileResourceRequest(urlOrFilename, readOptions?.encoding, readOptions?.signal);
        const res = this.serviceBus.dispatch(RequestFsReadFile.create(ref));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'readFile');
        }
        return res.value;
    }
    readDirectory(urlOrFilename) {
        const ref = toFileReference(urlOrFilename);
        const res = this.serviceBus.dispatch(RequestFsReadDirectory.create(ref));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'readDirectory');
        }
        return res.value;
    }
    readFileSync(urlOrFilename, encoding) {
        const ref = toFileReference(urlOrFilename, encoding);
        const res = this.serviceBus.dispatch(RequestFsReadFileSync.create(ref));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'readFileSync');
        }
        return res.value;
    }
    writeFile(urlOrFilename, content) {
        const ref = toFileReference(urlOrFilename);
        const fileResource = CFileResource.from(ref, content);
        const res = this.serviceBus.dispatch(RequestFsWriteFile.create(fileResource));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'writeFile');
        }
        return res.value;
    }
    getStat(urlOrFilename) {
        const ref = toFileReference(urlOrFilename);
        const res = this.serviceBus.dispatch(RequestFsStat.create(ref));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'getStat');
        }
        return res.value;
    }
    getStatSync(urlOrFilename) {
        const ref = toFileReference(urlOrFilename);
        const res = this.serviceBus.dispatch(RequestFsStatSync.create(ref));
        if (!isServiceResponseSuccess(res)) {
            throw genError(res.error, 'getStatSync');
        }
        return res.value;
    }
    compareStats(left, right) {
        return compareStats(left, right);
    }
    toURL(urlOrFilename, relativeTo) {
        if (isFileReference(urlOrFilename))
            return urlOrFilename.url;
        return toURL(urlOrFilename, relativeTo);
    }
    toFileURL(urlOrFilename, relativeTo) {
        if (isFileReference(urlOrFilename))
            return urlOrFilename.url;
        return toFileURL(urlOrFilename, relativeTo);
    }
    urlBasename(urlOrFilename) {
        return urlBasename(this.toURL(urlOrFilename));
    }
    urlDirname(urlOrFilename) {
        return urlDirname(this.toURL(urlOrFilename));
    }
}
function genError(err, alt) {
    return err || new ErrorNotImplemented(alt);
}
export function getDefaultCSpellIO() {
    if (defaultCSpellIONode)
        return defaultCSpellIONode;
    const cspellIO = new CSpellIONode();
    defaultCSpellIONode = cspellIO;
    return cspellIO;
}
//# sourceMappingURL=CSpellIONode.js.map