{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":8343749703648137447,"abi":{"parameters":[{"name":"a","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"b","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"24":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/expressions.nr"},"71":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // let mut field: Field = 0;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    };\n    field_val \n    // assert that the conversion is possible, i.e. the bignum is less than grumpkin field modulus \n\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // safty: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n    // validate the limbs are in range and the value in total is less than 2^254\n\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // validate that the last limb is less than the modulus\n    if N > 2 {\n        // validate that the result is less than the modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, result);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(result);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        result[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n    };\n    assert(field_val == field);\n    result\n}\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/constrained_ops.nr"},"74":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_ops.nr"},"75":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_helpers.nr"},"79":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/split_bits.nr"},"80":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::field_to_u60rep;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/u60_representation.nr"},"85":{"source":"use crate::utils::u60_representation::U60Repr;\n\nuse crate::bignum::BigNum;\nuse crate::bignum::BigNumTrait;\n\nuse crate::params::BigNumParams;\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fields::bls12_381Fq::BLS12_381_Fq_Params;\nuse crate::fields::bn254Fq::BN254_Fq_Params;\nuse crate::fields::U256::U256Params;\n\n\n// the types we will be benchmarking \n\ntype Fq = BigNum<3, 254, BN254_Fq_Params>;\ntype BN256 = BigNum<3, 257, U256Params>;\ntype BN381 = BigNum<4, 381, BLS12_381_Fq_Params>;\n\n// macro magic to generate the benchmarks\nfn bench_add<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a + b;\n}\n\nfn bench_sub<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a - b;\n}\n\nfn bench_mul<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a * b;\n}\n\nfn bench_div<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a / b;\n}\n\n\n// type Fq\n// type BN256\n// type BN381\n// type BN2048\n#[export]\nfn bench_add_Fq(a: Fq, b: Fq) {\n    bench_add::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_sub_Fq(a: Fq, b: Fq) {\n    bench_sub::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_mul_Fq(a: Fq, b: Fq) {\n    bench_mul::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_div_Fq(a: Fq, b: Fq) {\n    bench_div::<3, Fq>(a, b);\n}\n\n\n#[export]\nfn bench_add_BN256(a: BN256, b: BN256) {\n    bench_add::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_sub_BN256(a: BN256, b: BN256) {\n    bench_sub::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_mul_BN256(a: BN256, b: BN256) {\n        bench_mul::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_div_BN256(a: BN256, b: BN256) {\n    bench_div::<3, BN256>(a, b);\n}","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/benchmarks/bignum_benchmarks.nr"},"118":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, from_field, mul,\n        neg, sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range, to_field\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct BigNum<let N: u32, let MOD_BITS: u32, Params> {\n    pub limbs: [Field; N],\n}\n// We aim to avoid needing to add a generic parameter to this trait, for this reason we do not allow\n// accessing the limbs of the bignum except through slices.\npub trait BigNumTrait: Neg + Add + Sub + Mul + Div + Eq {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    pub fn new() -> Self;\n    pub fn one() -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub fn from_slice(limbs: [Field]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n    pub fn to_field(self) -> Field;\n\n    pub fn modulus() -> Self;\n    pub fn modulus_bits(self) -> u32;\n    pub fn num_limbs(self) -> u32;\n    pub fn get_limbs_slice(self) -> [Field];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    pub unconstrained fn __eq(self, other: Self) -> bool;\n    pub unconstrained fn __is_zero(self) -> bool;\n\n    pub unconstrained fn __neg(self) -> Self;\n    pub unconstrained fn __add(self, other: Self) -> Self;\n    pub unconstrained fn __sub(self, other: Self) -> Self;\n    pub unconstrained fn __mul(self, other: Self) -> Self;\n    pub unconstrained fn __div(self, other: Self) -> Self;\n    pub unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub unconstrained fn __invmod(self) -> Self;\n    pub unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    pub unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    pub unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    pub unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(self, other: Self) -> bool {\n        self == other\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_range(self);\n    pub fn validate_in_field(self);\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub fn udiv(self, divisor: Self) -> Self;\n    pub fn umod(self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::convert::From<Field> for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn from(input: Field) -> Self {\n        let params = Params::get_params();\n        Self { limbs: from_field::<N, MOD_BITS>(params, input) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> Neg for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> BigNumTrait for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    pub fn to_field(self) -> Field {\n    to_field::<_, MOD_BITS>(Params::get_params(), self.limbs)\n    }\n\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits(_: Self) -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs(_: Self) -> u32 {\n        N\n    }\n\n    fn get_limbs_slice(self) -> [Field] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__mul::<_, MOD_BITS>(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__div::<_, MOD_BITS>(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod::<_, MOD_BITS>(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = Params::get_params();\n        let maybe_limbs = __tonelli_shanks_sqrt(params, self.limbs);\n        maybe_limbs.map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Add for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Sub for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Mul for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Div for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Eq for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/bignum.nr"}},"names":["bench_mul_BN256"],"brillig_names":["__mul","__compute_quadratic_expression_with_borrow_flags"]}