{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":11878760977640627257,"abi":{"parameters":[{"name":"a","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"b","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"24":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/expressions.nr"},"71":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // let mut field: Field = 0;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    };\n    field_val \n    // assert that the conversion is possible, i.e. the bignum is less than grumpkin field modulus \n\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // safty: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n    // validate the limbs are in range and the value in total is less than 2^254\n\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // validate that the last limb is less than the modulus\n    if N > 2 {\n        // validate that the result is less than the modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, result);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(result);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        result[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n    };\n    assert(field_val == field);\n    result\n}\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/constrained_ops.nr"},"74":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_ops.nr"},"75":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_helpers.nr"},"79":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/split_bits.nr"},"80":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::field_to_u60rep;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/u60_representation.nr"},"85":{"source":"use crate::utils::u60_representation::U60Repr;\n\nuse crate::bignum::BigNum;\nuse crate::bignum::BigNumTrait;\n\nuse crate::params::BigNumParams;\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fields::bls12_381Fq::BLS12_381_Fq_Params;\nuse crate::fields::bn254Fq::BN254_Fq_Params;\nuse crate::fields::U256::U256Params;\n\n\n// the types we will be benchmarking \n\ntype Fq = BigNum<3, 254, BN254_Fq_Params>;\ntype BN256 = BigNum<3, 257, U256Params>;\ntype BN381 = BigNum<4, 381, BLS12_381_Fq_Params>;\n\n// macro magic to generate the benchmarks\nfn bench_add<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a + b;\n}\n\nfn bench_sub<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a - b;\n}\n\nfn bench_mul<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a * b;\n}\n\nfn bench_div<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a / b;\n}\n\n\n// type Fq\n// type BN256\n// type BN381\n// type BN2048\n#[export]\nfn bench_add_Fq(a: Fq, b: Fq) {\n    bench_add::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_sub_Fq(a: Fq, b: Fq) {\n    bench_sub::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_mul_Fq(a: Fq, b: Fq) {\n    bench_mul::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_div_Fq(a: Fq, b: Fq) {\n    bench_div::<3, Fq>(a, b);\n}\n\n\n#[export]\nfn bench_add_BN256(a: BN256, b: BN256) {\n    bench_add::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_sub_BN256(a: BN256, b: BN256) {\n    bench_sub::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_mul_BN256(a: BN256, b: BN256) {\n        bench_mul::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_div_BN256(a: BN256, b: BN256) {\n    bench_div::<3, BN256>(a, b);\n}","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/benchmarks/bignum_benchmarks.nr"},"118":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, from_field, mul,\n        neg, sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range, to_field\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct BigNum<let N: u32, let MOD_BITS: u32, Params> {\n    pub limbs: [Field; N],\n}\n// We aim to avoid needing to add a generic parameter to this trait, for this reason we do not allow\n// accessing the limbs of the bignum except through slices.\npub trait BigNumTrait: Neg + Add + Sub + Mul + Div + Eq {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    pub fn new() -> Self;\n    pub fn one() -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub fn from_slice(limbs: [Field]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n    pub fn to_field(self) -> Field;\n\n    pub fn modulus() -> Self;\n    pub fn modulus_bits(self) -> u32;\n    pub fn num_limbs(self) -> u32;\n    pub fn get_limbs_slice(self) -> [Field];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    pub unconstrained fn __eq(self, other: Self) -> bool;\n    pub unconstrained fn __is_zero(self) -> bool;\n\n    pub unconstrained fn __neg(self) -> Self;\n    pub unconstrained fn __add(self, other: Self) -> Self;\n    pub unconstrained fn __sub(self, other: Self) -> Self;\n    pub unconstrained fn __mul(self, other: Self) -> Self;\n    pub unconstrained fn __div(self, other: Self) -> Self;\n    pub unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub unconstrained fn __invmod(self) -> Self;\n    pub unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    pub unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    pub unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    pub unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(self, other: Self) -> bool {\n        self == other\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_range(self);\n    pub fn validate_in_field(self);\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub fn udiv(self, divisor: Self) -> Self;\n    pub fn umod(self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::convert::From<Field> for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn from(input: Field) -> Self {\n        let params = Params::get_params();\n        Self { limbs: from_field::<N, MOD_BITS>(params, input) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> Neg for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> BigNumTrait for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    pub fn to_field(self) -> Field {\n    to_field::<_, MOD_BITS>(Params::get_params(), self.limbs)\n    }\n\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits(_: Self) -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs(_: Self) -> u32 {\n        N\n    }\n\n    fn get_limbs_slice(self) -> [Field] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__mul::<_, MOD_BITS>(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__div::<_, MOD_BITS>(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod::<_, MOD_BITS>(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = Params::get_params();\n        let maybe_limbs = __tonelli_shanks_sqrt(params, self.limbs);\n        maybe_limbs.map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Add for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Sub for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Mul for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Div for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Eq for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/bignum.nr"}},"names":["bench_mul_Fq"],"brillig_names":["__mul","__compute_quadratic_expression_with_borrow_flags"]}