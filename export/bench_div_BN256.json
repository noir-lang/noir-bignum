{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":15901894513381514175,"abi":{"parameters":[{"name":"a","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"b","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9209328183999706539":{"error_kind":"string","string":"BigNum has no multiplicative inverse. Use udiv for unsigned integer division"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+29CZhkWVkmfCMzItfKyqwta++qaptu6Oquisg90dEUhmm2Zt9/HMzKrEJRFFQYGEc7WgEHdWRcRhCQxV9ppB1BEMeRUfkRFRlBBpfxaUUdFcUWl0ZkEBT+ut1xMt584z3fPTfinliy4j5PVUbE+c75lvOdbznbLSUPPOeu/juV+J+Nxt/F6srS0uXVhcu1xdpmdWH90tpydWn50spaba22vLa8vbC2uHh5bWltdf3S+mp1vba0eLl2ZXl98Ur1gafcaGciAFe1w6d0tY3RyDgGqN1a+l8qk7FkKJMBbbcWqd37n1Q39iXJUDcGs92oujFsd9guPoX41ppd3Ha71Svm0367fk7SdofxBj5L9/+vZFIqlvZaDDkUTWNpAGgcSeLah6LpHR0AmZYHgMZKwf3uaHT9n+Yb40kj5ys3Cn2BZoGMDRPA3c8wARz8docJ4LBd3zNMAIftdq3dYQK4m5NhAshP9xLAsaT/g+zxAaBxIinWPpQS/RSJY5hkXptJ5l7QrSLpjUXjtThxFVu3RkEO7vPk1X9TV/9N0+9pPjZz9d/+xu8ud5+9+m/u6r8DV/8dvPrv0NV/h7HRUqPRl9BvU+K3FOlRIKrIzhltEM3tdrqT4EhSrGLGMMox+J7vc74rDb5HCuL78tXAOm13skAZHu1zGaZjZjyC7hwbgDETg+/jAzBmxiOMmakCZXhiAMbMRATdOTkAYyYG36cGYMxMRBgz0wXK8HSBMsR4bbbxF3+bE78dEL8dTFoD3DLJsLZyZWVlc3N5e3O9ury6urS8vrW8vLqytrB4lf3lrfXl1cXq6tri9vLylUtbm1trte31hfWt1c3NlYXF9drKSp5+Xsoon0W61le2Ly9ubVdXNmtLa5eWly+vbV6+vHR5+fLq9tXuWdyuVRdXq9VLC4uXtjev0rmwsnS1O2rrS+vbWyuX1y8dKbBvrytQl7F/0na/nfpnvOD+KRU0Xq5c2arNFtjXcwX29XyBbR0rsK3rCtTBM8XpxCrq4BmhgxMF6+BIgTo4V6AOHiiwr48W2NbxAts6WWBbZwrU57PYj4vVqxq1WtteXdisXbp0Za1W3d5aqq5tbm5V11e3r1K7dmVra2Hh6ufNS5cu1S5fXryytLRWXV5cXlu7qo2oz2eFPo+RPneqgwcK1MGDBfbPiQLbOlVgW2cL1JtzSZw465zQm9F8erN12aa9drA42msFxpu1ImWK4y1pyHakIcs09qwkrY/aiHL3ux/zrurJD9+h+uONP3ndu0/++cizsKxslFWMslmjbM4oO2CUHTTKDhtl80bZMaPshKfM5Us/12h4kn53+r/R+F7t7KlNQrtFt79WXVmbTHY/BdO/OJk059KLb39hwbU/FYf+qssdHl5vto+8OLyjBMd1EOY2gLkNYMoA80iAeaQH5lEA8ygPzKMB5tEemMcAzGM8MI8FmMd6YG4HmNs9MI8DmMd5YB4PMI/3wDwBYJ7ggXkiwDzRA/MkgHmSB+bJAPNkD8xTAOYpHpinAsxTPTBPA5ineWCeDjBP98A8A2CeQTAzSXNewz1OV914imHP1qpLS5HH66LjDe2a49Phno6De6lE+JKk2R9Y5vBPJTFt4wPzIojP0cPycX0942DqTXq4rFxv5cOVVaDM9W+a974U4Fi3HB2Tye6F24L1bjWy3q30UO9W96LejVJZud7KR169Q5mw3pUjyOKq3m1H1rutHurd9l7UuzKVleutfOTVO9Qt1rtKBFlcncVZH/rZwdK7CpWV66185NU71C3Wu7EIsriqd1tDvRssvRujsnK9lY+8eoe6xXo3HkEWV/XuylDvBkvvxqmsXG/lI6/eoW6x3k1EkMXV+bOFod4Nlt5NUFm53spHXr1D3ZoEuJfB7yWgC+kuCbrj5sIryzFznmpDZ+/nsd5s35pH4FwP5Y43nr2U5BNnjqopnxjyT+VzyEO/+5w+4/Vk5xkleaKMnMwmEJ7KJqGsXN+NZ6rxHecOsS1HR4Xgv7Px3a31jEEdV39O4B8j/LvoFr+hjLitUfGbg09jkP/Q+JyO61R/XgVrNmyzizwE5OwC2im22fvg917MBTn8U0lUH7Jjs/cRPSwftA+lpKm7WHdOlGEfYhnimRF4hm0V15bbT4k6PU14VP/vM/BgfQenxk6B47bGuudwIO798Hsvxq3DP5W09keMcbuf6PHph5PdrKB1TpRhH2IZ4pkVeFRbU8O22mrLjVvUaR63qv/3G3iwvoObEfVKnr8OD//GeBTNrINF4FFyc7ZgDsrSfxuN79WOnsWdObQD0H6Rexpc+wfjtF9z7R+K037LWhvKKo373kP94vq3krTmi0hnheAvzzfb/KXGb27M4NzqfirDtnk8YZ5q5a5qPDk4a06gXT1XNFv+sF08Kn7g/Qjcnx+E31He2J9Yl/vTwV+A/vxQ4zfXZ9baIO6v22j8rXb4hMzrRPLtwfM6Dn+35nVULOqb12Ef4Ooq/4Bjlf1QiE+L3dZs0trfk4Qnb5yO9R1c7PHM4yZSrLwz5zobp/2dPYuHge922+Y7mrJs3cfh9/TfkcZ3n62bhXKE/5cjzTY/0fhN2boZKsP+ZN+VVwenBZ7YOsi+yyfn++B3rBcqZwf/SyDnTzd+s+TMc/bps9H4W+3sCcpfj8DvvfApDn+38tcjRI9PZ53s5gWtc6KMx8a8wDMv8Ki2KhHamk38Y5B1HvFMG3iscabmOtsdz3ntRmTdDp6b2Su6HUMfh23la8v1GfYx6zvW68W+Pod/Kok6/mqWXI8IuTr5HI1Dz1aJ2kd6jgr5uL48JspcW8cb3zH+QPijwCPC42dXH3+7sdFhc6JNnlM8JvjB33Bt7WxpN2/YN6ynkfphM1RPHf6pJOq4qVl6oca/0gtXV/UX25nQ/hq2NWyrqLbKoi22YQp3+tnlXy42Rbvg6s4I3GxP0PYVN35ri6H2xOGfEjzGsCeWXNOH/d6JOPJZKFH7SM8JIR/XlydFmWvLvTUR/R7CnwAeER4/u/r42+PI72Gb7PdOCn7wN/R7j2y0O+nhZ6PxvdrRU1uJ25fVS5NCLoW1X2vO0Z2KIp+FHfmcjiOfnT1g18Vpf9O1fyZK+801xLNR2q/t9O+5pPm03TZNkrq2r++87ZYr8l3bXxKnX3fO3dwQp/011/6DoP2OZE+Pa//GOPTvnMO8KQ79O2vPD45D/864egi039EepJ3XKmzd/zVr3tolPQ7m5kaZb976JJQj/NGJZpsu4Vfz1m4uzpXhXmeeT8S3Eo+K36z5RNyXzfVKnr8OD//GeBTNWXJ+Psm53fWBj40323yBIWdHoysbFzSXqCwBWsYN/rE+nrvgep3K2aJZzTWPirasmAznhTmXwD4+STzGmptmnfXp0h2kS66eT5dOQznCvwN06TsCxqySG8KVk9ZxyvJKRBs+3WUcCv/1VHYygDasb8XqDJu2oeKsjuw1RRRsh0eT5kv6kK4zJL/zje8jAH+zAc98cfvnA2SSiN9cXnU9lJ0k2DP03acrXMZ9yu2ynmDdc43Panzz2TF1vsftRSjXd+PbaPxe7exZTfH8l/kmHSyLSn23HCx7lj5s/24W8NinzkbMJX7dUXaZ+8uVVZLW/qpQmYN9U8P2xDxblz64PzFJtJ9Udo91L0lsn6Ns+6iBZ75DPPMCz4yoV/L8TZIwX6VozvJVd5OvQv1Qvor32jn4F4Ov+mnyVXz2HMvGBc1MS5KExT1Yv1txD9Osxv2YaMvBnxbwOO6tuOc08cj2Vv11eJIMHpGG0LjnF0mXsuKeG6Ec4R8FuvReQ5dOAj9MM8L54h6UVyLa4HY47hkz8HPcczqANmXvfW2cpDZ6GfcgXZ3GPcwXt38+QCaJ+E3FPacJ1op7Thpl3KfcLuvJAMU9myruQVlU6rvlYNmz9AmJe7BPnY3IG/dwf3Hcg/3li3v+qGF7+iHuqQjeSlSWJE0Z4m+Wba9QmYrfVUx0jGjIGxPxGlr6xI6JjhEenx+7l/wY6ofyY18C5Qg/BX7sb8iP8T1QWLZX5OxoVnGc0k8Hr+YVcWy7uXYVE0x4cKexflnAu/UqvsvGladP3PEfvg7t8E8JPmKsQ6t+ULGs2tfi6io9xL7EMsQTuoeh3T1Nw7aGbQ3bGrbVL20pP4p3tTlcrszFjCnMDSO76XH1fPHKdVCO8B8ea7Z5U6PNvPEK7ynLG68oPLHjFT5DgX6V53fGBD9jBh6sz/05ViA/iuasOHeF9CZr7u9LoBzhfxT0Zt3QG3wZL9PM64d55Twj8MSWc+ja8sNyypnXlh38c0DOjxgJw30b4R7JwM3zuw7+FOB+NPUxxu/cx9j/eF4Ay5IkLG/F+nxuAut12seK5iw5PzmnDWY5O/iPVZptPs2QM9usa0XOzylIzm8AOV8iOau5ob0q51jrIqF3PXwD9WfWmsGDoRzhnwv9+cI2xw3PQ+TtT4Undn9yDh7L1z2I8MTSG8bj05t6QXrznSPNNt/qabMEbeL+7BJ9ngb6FA0niAYH/10NvCm+t9GdhZHOlO6caTsk5Kb2z1UI/nuA5v86v1sO6t4A6xzJIQGv9gqqM86ubuQ7iHbkNZ8hL/Y3Dv4HDHkp/kcMealzkYcMeaEsOZ/BcePmR9V5bB43PwHj5jWecVPOaHNElOGcI4+THwOcr/fgTBI99nCNJWSsTnhoeBP04ztoXUzVR1tl2VVlC2+CNt5qtHFTzjbwfdgJ1RkRbTg4lIcr/ynok3d68pz0CdHrrHl/3guh5F0iPKiDCM/nLlGeri7ypHBi7IllPwcyeTd8/usccQnSw3Fm3tz4iKA5drzQb3Hm+wqKF6oQZ/5qjjxY6Ve7/anwhMSGOPY67QOkge+XVPu9rDFu7Y9S+8hxrLNNUHsflZzLAn6fh9YxDzyPfwf/u8JHsE30rUe6OyaVnMc99E156OP7KrFM4WYbOi34nzD4d/B/KOJZSzfU/hYHF3d/S21R7W/ZFYPUtUySpFUf04f1V8XC6lyDdXZDzVlbe/JwbeAvc86XnIXyXf0Adu/enD7tWstNP12Qr/m/IOdTo7rNUhI3N/38AOamXxzmprly07FRv7wGMTc93uAn1fV9nnFTdG46DzjnPDiTJG5uehj6MTQ3/XQBuamzTZ3kpq6NInPTs9AnN1Kf7IXc9EZDZr7c9CEgk39L9Yf5aHt42slHlz02Im+M8NFys801oz+H+Wiy43fdZ9+43mv56COFX2A7uJfz0ccD/8N8tBW+m/nos8jutZuP3g1276ty+rRrLR99bkG+5nkg51f1KB/9BjGW+z0f/SYjvxrmo6356Ev3WD76vTBu7uhSPvpKwPmdPcpHv6uNfPS5Ri4Zmo++qoB89FUR8tEfhD75kT2Yj/5IG/no60Em/2uYjxaCp5189K0FxQjfAnHZ3TnyUXw3Met6mfjn36xcsExl/ZCP8nuY3WefHbDigbx2wMqvEI/Kx/Z5aB3zwLv22A6+x8hHXX3MR1FeVj465qFvKrFz25KHdsbty3d9+Tjz7+DfZ+SjSjdUPurgepGPoo5W6lomSdKqj+nD+jsl4NV8yhzBY3+pfJTvf8FxjPnoh8juYZ+F5KMO/nawex8J9GmOXuuddCUqS5Kwc1STAk/sc1T8vkKfr7knp8z5PIyDPwUy/1iO2OFakfNfFCTnvwZ9/isjxnM0Tidhvq4CvDp69hNMkjTz1XFqa6Pxvdrhw/Yf7+RRsT3PRX2a5Oz6ZzRpPTfAMkN7h3hRr/YT3gnCm35/13xXZLXFNFc8PI57aP6skdsXnQNZOcOEUY9jfv5N8XvQQ9uYB943V+8GDMZGke+f2WK9xT5VMqsQfBlo5j5VfWT1qXpfrprjV+d3Jqke0o7nb/i3EQF/mGBZJ5SeRR57i9bYKwnaWLf2i37qXWxZXVKxJfZTBfD67IM6jxVqH5zM1L3RnEuoHBRlzuPf1ffNmXFu4OCPi/FvnVmfMdrGGCDEHzsaQv1xJHtU5f723d/H/tjBP6i8GwbvR1a2oUSfpwRe9Z77CsE/CPruXV2x3c13tEwBTSG228E/pEDbnZXLse1W81SqHs+N+WwB8nvQQ9uYB55tpoOvGf4Yc9EYfaruoFcy43n3ZaNPVR9ZfarWl6eE3FSMxfeS+2Is/k3Nq7M/Zp1QehbZTi1aY68kaGPd+ooB8MfYT+yP8+6dybIP7I+VnrXrj3GuMsQfO/hHB/pjXjfw+eN7Avxx3DiyaV/ajSOfZNiXouevHT1WDheyhoB0WXPVTJdvbtsnm2cJfWGdxblttT/KWscoES04t63myUuizNo71in/m8B/yF6rXsZHITb6SqCN7uX+sG7Ox1s2mnW0WznTCwNttLUmgDbarQk43eT3BGw0vlc7e3bmXXDfiOJ7mvh28C8x7LCK2yw7nLUvkO2w2vek9hyNG3jUHk7G6fbq+PZ8+vZc1Y24Pfa+pyNAk+pP3vfk4F9m9GfefU/qXfGHCCZ9VJ/xfgqk19qjNErfGWdZtIn+C+vNGfyURdusNztnmzzw2EcI/32G/1bv5EFZsZ3M0l2mwcH/gOFDVV5cSvyynjboO5JBH9sdB//qQPo4D4v0vnhzvyGOO1+fvz7Qx08AP+lTrkfhZ1v5eOtdQ2qsW+8aUnsiecynj7rDkm1I3r2EOCZC4jAHf5fh49Wcg/WOuqw9iG+lHK2XcWvWewh9ey/fkXNer5MzL+xL1JmXkHNHSFdIjqLOgyC8TzY/b9h4tf8Iee32/iPL3rfL/y8b9pvnHNInbhzc1PV24+D3B9rvceAnfcr1KPz0/AwP2291Ny7rHLZl2e+seTRe13bwvxWYozm+Z4y28RxRv+dovzfM0bw52h/1MEfLihV9Z1P+tMAcLetsCvcnyp3PpvRDjob8hORo7h58X46GfYTwn8yZo6Gs8uZoTIOD//su5WjzGfSx3XHw/9hmjsbvqtxofK929mxxn/vGna/PPzfgOZoa61aOpt4pwWM+fdQ7JXqVo1Uam1K6kaMt74EcbT/Ia5ij7YafF7pUIhx7OUc7DfzvhRzteqHrwxytv3K0Ww373U6O5u4e7Pccbcmww9d6jvZlQif6PUfbMPpzmKM1n5g52qMN/92tHO1xhg/thxztyYH0DUqO9oxAHz/M0XqXo211MUd734D4/6/L6f8tf7HX/P83D6D//3c5/b+VVw/9/wNPXv9/Zx/4/5f3uf//7kD6GmB97/9fNfT/fe//X2v4/wrUL8L/fwP5/0jnYldKguc85xl+zPAX6jyDpROqH/OeZ1DztzzvqNpWuH12Lm1D3ZuY/r7R+F7N+dToO4+r0cSOPXhcjSTaPzA888XtHwuQSWK0r/oooTLlsw8bZb7+VHLBNhQtrg3Ld5SozdAzvmizChyzLbqBMjgm6GHf+Z7KbpiTICcl7xJ9Pi7wngQYPuN7nPCmMuYzvpFktcU0Vzw8HvPQ/MsD4JfR97Jftvxs+rANPi7gsW8c73MEr2y1sv8o85B7P9QdyuyDPhjolx3fynZ3KxZUsQDHgr8VqHPIT/qU61H42c673qNsr7Xeo3TUujsb9ZHvMcP+5lyjW2tBfyD0MWu95zkDEu/9n5zxXid3EDl6hvFeE+cw3hvGe3njvc/1KN773ADGe18Yxnt9H+9NNgb2Xon39gM/w3hv8OK9E0Ifs+K9JzeEYt3v3e+x4Dmht5YtKDIWVP2u6iFcWdDCtCYe3NjOCMFWDPzXU9lEAG39FKdyoMqxyKDEqeOAH/uFZcz2zNIVLvPpZZJoPcG65xqfQ+wB8hrDHmStHfP6iINfD/RjI8BP+pTrUfhZVX6syPte1JoX+6D0UWfBWd9HRFuWr1KxE8K79thm/2sjdlJ3FFk+AuVxyIPvkWNNOr+q8TlyPGbqMdLM8ZiDf6zh11Ssk1dHkG8Hr/JRrKvskrXO3QsbMSJoY9k+JdBGdGcvu7YRTpb30w94fTYC4fPaCAdv2Qg1Ph1OHFcq5hwBuNtGNC+lxN6fw7rvszlsAxz8FvT52zz2OP2M9+9fHtO4fbnVhAf3N4D9+RpqU8WondhcX5z89YH5AeYfD6P8wDrjoHRMxc7u8zHBB8L79qh8s+BjlmCQPmeLcK4ohi06BfTynAfirxD8Sww77+qgTDFv5XF+SsAj344eJy+cRznVHXmtW/IaD5DXHTnlVelAXnw37jFDXqfiyGvnjtrTQl4lQU+F4F9hyEvxb+XHpwX8KYJBeaEssS7Wc7kQyvYkwR6j7z3Q247H+asCY44Z4Cd9yvUo/MiYA+dhOeZQYwvh27VFc0mrHh2jMvQ1xwmPFQsr/4l7PUPmRx386wz/qepj/KDOfbL/dH560Nd53kLxjVrnUfmp+9zuOs9boH+6s87TPFOr1nnUPBHT/DbDNqv5acuXZa2hOHqcLqLNOm7U4/yPf1P8HvTQNuaB51jPwb9TjLnJpNUOxOhTtOOjhswqBP9zRp+qPrL61LK5SI/K209SPbU/PxG/jQh4vrufdULpWWQ7tW6NvZKgjXXrvf01B7CZd71L2QdrvSvLPjiZqTVW3hOfN2dVPhfhOWd18P8zcJ7Q8Z2Vz67Q3EPW2twNieY779rcRw07FmeOrGnH1Hqwkh3n2b9n2LG880+WriI9Kk46RmXqnhimy3c/f3dyhabss3I2zhUc/B8H2iac40ifcj0KP/KuDexTtk155y1UXnmSYNJnjuBZj0LGdN75NB7TDv5ewzahXh7z4MPzfqijnN+4svFEr0E+xNN+KZD/k4J/hkH+Hfx9Yj7VjavTRMNG43u1o6c5rs4ATcqenCaaHfw/GjZN6aCls2cEvNJLNRdyJvHjLgv4cQ/uMQ+8j/9/NvxQbFuY1WcnPTQ75rNsoeurfnt/h7KF1lqd0ivsGyezuaRVl05TGdoh690ZuCfoBtoDzv52o/G92tmzzvbN5yN9MdV+oReWD8B+YJmreJbnZ9JH7fsZp3oh+37UGrevDd53rOLGGHvATwNN1r1nrLe4tybET5c87Z8JkElitK/6KKEyZYcOG2Xt7pVStLg2rDvh2KeHzg2eobY2Gt+rHT6sGyiDM4IejmtvGt8NczPIKWRu8EaB92aA4bnBGwmvmhuMI6um37sRaFI8nvHQfD7Q7/Xyvj2MW9jvWfFR+rANvlHAY9+w37sRythWK/tvzU+qvF7lp+yDVqCPrBzA8d2tnF/FWlbO7+C/NFDnkJ/0Kdej8BP9XWlKR1W/q1irQmUq1mJfhHjQtuV9j5prr0Lwtwl9nDHqp/XubRSEzCGr8ci+EH0+yjdJtJ9QeRvjUPivp7KbA2jD+jcDLtXGGWrDjd3z9PtG43s17+PZ03wL0FQWdJ0n+d3a+I5x1y0GPPPF7d8aIJNE/Kb2NN9MsOfpu09XuIz7lNtlPcG65xqfZ0UZ+k7mNUau4/rFl+vcDOUI/5y+sst6rQL7j+2yGmsIz3b5FgF/M8Gkz1ySre9qXseyvQ6Pz/by3IqDf54RC6i8pls6dx7oVeODdc7Bf6ORX6v+xJiL+/O8gEe+HT2zSauNYpvBY9+KEU+KesofOvwpD79Y2g3n2xv6Espl1N50rDsL5Qh/53izzW+lNru1N/SOwLgB4+S7GwUqbuD89WQGHxwvnc7gw7du8grBh7L7jr5ejkGlmzwGvyfnGLTyq6wx6OixxmBkea1Y8ioFyOsHcsprugN5lUhepw15nY8jr0X2lz7bc57k5eB/xJCX4t+y8cpnI9+8lxZliXWxnosplb9Kklad75HedjzOfywwvsO9NelTrkfhJ3p8F2qL5pJWPbLWOHy5JeKx9oaqtVDrfIeD/2nDf6r6GD8o/zlNNIfk3Wp9MRG/lUQ7vN96mHe30rWX8m6frnAZ92lW3o11zzU+q/XvLuXdK5Z/LAm+2D/+WqBdPgn8pE+5HoWf1UHKu7Ni/rx5N8f8Dv5/9VfevdJpLPB7OWPYUfgtRszP9CaJ3yc5uU+LeiqfRH97R2k3HLaBefcfU46s9mljXc67HfwnIO/+U2pTvTPA0l0VNyD8tIeGvwjMu/EdZM9vFCi76luTTzLoCh2DvFbp4P/GyLtVfODGINqPGGPwVqBXxSK3ED8O/lPGGLRsZPrwGLxVwCPfjh4nL7Sjt3ZHXouWvEoB8vqnnPIa70BeJZLXzYa8bo0srwtCXtOCngrBu4Gg5KX4t2z8BQGPfPO7IVGWWBfruZjSytF9MWYX9bbjcT4p+qHf4jv0wxXA6xtbCN+uLZpLWvXoZipDXxMS++G4YP+J+1kVvG9v6BHoP/afqj7GD8reWmOFy1A2fI+OkjP+xvdtYH0HNyPqlTx/HR7+jfEomh0eHOsYb52bSHbxpmwe1uV4y8G/7EizzRsabVo+T/UBy1np/y0G/1j/FuKf7Zv66/Dwb4zHolnZa2vMXhTwFwDG9ZXSy4vEI9t79dfhSTJ4RBpYZ326tEi6pOy2Whdku/100KUVQ5cuAD9MM88nKd+J8kpEGz7dZRwKP8+jXQygDesrvbjooRPn0ar0+0bjezXv45lHqwFNZUFXleS30PiO82g1A5754vYXAmSSiN/UPNpFgq3Sd5+ucBn3KbfLeoJ1zzU+q/GNNuz++vVW/L2IWVAWlfpuOVj2LH3Y/tUEPPYprwco3VF2mfuLY0TsL95v52Cf0rA9kfONKsZLSaL9pLJ7rHtJYvscZdvPG3jmO8QzL/CouLfk+evw8G+MR9Gc5aueQ75KzSFjXb53zMGfBl91iXyVmj9V45zlnDe+xPrdii+Z5qqgWcVq1rhHX8BxD9qEGvHIdlv9dXiSDB6RBo6vfLr0QtIlV8+nS3hmAOH//nCzzW8xdKkK/DDNCIexhfLRifitJNphf3aLgZ/jnloAbVhf6YUvXsC4Z4F+32h8r+Z9PHHPItCk4pgFkt9S4zvGPYsGPPPF7S8FyCQRv6m4p0awC/Tdpytcxn3K7bKeYN1zjc9qfKMNu79+vRV/L/ZIoCwq9d1ysOxZ+rD9WxTw2KfORswlft1RdtkXw7LfKiWtcY+D/QGKe7BvYsc9Dpdl91j3kiRsfkDZSRVDVIkGLOPz/nljIqzfrZjoGOHx+bE35IyJvgTKEf5nwI+9OUdMtFfk7GhWuZAVE6kYCsfeDY3PKoasenCn85plAe/uSrHiRDWnUNz4ry2GyBzxTwk+CrRHNasfVPztZGflpFjGvtOKdRCPamtq2NawrWFbw7YGvC3lR631BhczprHF7+dcb7gOyhH+RRCv/EGb8QrvYcgbryg8seOVW4ifvTInlRXn3ptzvobjXAf/r0Fv/sbQG57LvVbWlj+TU868tuzgx0DO/zQRhvvzBc3v/sqhZptfaLOPjyS7acnbx0cEnth9fITw+OQ8Ppns4i2rj1nODv5lIOepRptDOT/wpDI5VJCcHwFynic5qzX/vSrniwXiwbxuivD4+vN66k+XN/r688FQjvD7oT8f1Oa44dglb38qPLH7k/f3xNr78iDCE0tvGI9Pb5YK0pvVyWabz/a0WYI2T8BvfGakBvQpGk4QDQ7+Sxt41R2jC0TDRuN7tbNn5z26i0JuyPcC0ezgvwJo5r29uI7i2izDbyFrAMg3z0Nj/uTqTtL3WPJaypDXIsnLwf8bQ16Kf2t+dEnALxryQlkuUVs4bqz1PB43z4Rx81jPuClntDkiynatLVH50wDnEzw4k0SPPd6LmzVWqx4angL9yHtxVX20VZZdVbbwJmjj2UYbN+VsQ50pcHVGRBu4B57jqK+GPrniic3Sp4h5f94LoeRdIjyogwh/tPFZydPVRZ4UTtwjjGXPA5l8LXx+Y464BOnhOFPtrVV7y1Sc6eBixwv9Fme+uKB44X8fbLb5UqM/nSxUf3Kcmbc/FZ6Q2DDW3u8pg1c+M6HGeN59kXn3Ryk5qz21+zy0jnngefw7+FcKH8E2EdcjUV5zjc9Kzhc99E156JtLNO6SBzfb0Jrgv2rw7+D/s4hnLd1w82i4v8XB9eLuzSL3t6hYGPXS6e8cwWN/WXszstYGXkd2L+tcy1koR/h3gN17Q06fdq3lpm8tyNfcDXL+SI9y07cPYG76rmFumis3/YU9lpt+CMbNe7uUm34QcL6/R7npB9rITd9aQG76kQJy049EyE1/B/rknj2Ym97TRm76MZDJwand9Yf5aHt42slH/6qgGOGlEJd9cpiP7uqDYT76wPPP13g+OjrV5H+Yj7bCdzMf3T+1m55289Engd07MNX8HOLTrrV89CTJvF1fcx3I+eGeNktJ3Hz0ejGW+z0fvRFoHuajrfRwPnqrIa9BzEc3YNwsesZN0fnovwKcqx6cSRI3H/1S6MfQfNTZqk7y0YcbbdyUs40i89HboE9upz7ZC/no7YbMfPnoE0AmLx/mo4XgaScffXZBMcJJiMueY/TnMB994PO1mI9+o/ALbAf3cj764mE+ugPf63z0zoLy0U8faLb5skCfZp2jmkx205X3HNWkwBP7HNUk4fH5mu/LKfNZKEf4XwGZfz/JOfSuRZZz3rsUsH63/EmonF9Lcs46F8hy3rkHA+T8o0aMx+fosA84/8+rz1j//BDPQOBxZdMBeEqAh9/NgZ8x3xgVMHyHroN/p/C53GZJ8Ir+gscR0nBQ8M/j6OcMGvBuxFFBF7/X5kJOeMxZOa5U8Hy3BLfv2psUbRU4l7TC9KPtUncBcs79S8ZcksorRuG3EY8ME48MeXwpeal6txIeiz9XPirqci7BuoUxtcqts9pEmFs89JcF3rIHr8sn+C7KD0L89NWN4FfJdIb4HaR7kjkWSz+j7/5ogO/Guj7f/Qzw3b9rxEjsu/eKnK2xrvxZ6FjnvBrHwEXisdf3Uf95zjjQdx/1edClvzR0CX2Tz0Y6W6FszvA+aisl3/3VyaMGNA3vo9Z6wu0O76NuPiHzitinvbyPutJIKIb3UbeHp5/vo56bTnbx1u59JffNNds81GgzZA7uVkEz+80kabUZiv/hfdTNp1MekQaOr7x3S5AuqRwS694I5Qj/ftClBxm6VAV+mObhfdTD+6jxNxX31Ah2eB91y3NN30f9cIp7sG9ixz0Ol2X3WPeSJGx+QNlJa01PxUR7+T7qx+eMib4EyhH+5eDHnpQjJtorcnY0F73X6obGZxVDVj24h/dRhxNk9YOKv53srJwUy9h3Du+sHbY1bGvY1rXclvKj1noD7ql6JcUrWesNvvuoHwXxyve2Ga/wXtLhfdTN+t2ek8qKc1+Xc76G41wHfwz05g2G3vBcLtLM64d55Twj8MSWM68t++R8V04589qyg79nttnm26bDcP9UQfO7rwbcb2+zj/fyPck/n7OPffckPwPk/J6hnFvk/P6C5Hwc5PzrJOfhfdTt4WnnHMxvU3+6vDHvOZg/3d9s8/faHDfD+6h34+nnM9YfL0hvPjHdbHNmn26zBG3GOGP9yQYNg3TG+u+B5uEZ61Z6+Iz1/zXkNYhnrKcaYyXV9X/xjMWiz1iPA86SZ6wmiR57RZ2xrjTw5jlj7WyVZVeVLcTz0c42qTZuytmGOkuC+9W5DeuM9QHok6PUJ0XP+/NeiG6csT5qyMx3xvokyOQEfH4CtTU8b90ennbizJs89iL3HaEQZ95s9OfwvPUDn3GezTfG99p564cKH8E2cS+ft/5K4H943roVvpvnrR9Ldq/d89YvA7v3+Jw+7VrLTZ9ZkK95Nsj5zh7lpl8txnK/56bbQPMwN22lh3PTrzPkNYi56bfDuHmhZ9wUnZt+K+B8UY9y05e2kZs+08grQ3PTOwvITe+MkJu+HPrke/Zgbvo9beSm3wcy+ZVhPloInnby0dcWFCPcDnHZjw7z0V19MMxHH3j+6zWej/7sMB/dge91PvrLBeWjN4Lde19On3at5aO/WZCv+S2Q86d7lI/+9gDmo/97mI/mykf/aI/lo/fBuPnzLuWjfws4P9GjfPSTbeSjv1lAPvrpAvLRT0fIRz8LffKFPZiPfqGNfLQ006y/MrO7/jAfbQ9PO/nozEzzdx7TeWKEv4P+nDP6c5iPPvD5WsxHzzb04lrNR28C/of5aCt8N/PRBbJ77eajHwC7txzo06xzVHv5PuqvyCnzWShH+FeDnB9Gclbn6FQf7OX7qB9Dcs46F8hydvBXQM6PIzkP76Me4vHhcWXTAg/eNVuiMsSJ4+Wgh8YxD7xrj++62xbxx4xRP21/s1EQcm4E71p0dO0X7ca9V6J5Z5Pzk767plhODv4bqX/wzkmOTZUO1QRe9N/7CW+N8Kb98675rshqi2mueHj0zXV8M9DMc1YqpldjiWlAeBVXWjG9qsc5Jv+m+A2ZC1L3tbbsjxBjbpJgYvUpzsuNGjKrEPwdRp+qPrL6NCvOdfSoPKDTu14R/jDBsk4oPYs89hatsRcyz/hK0U8qZ7oV+Emfcj0KP0t574otOud3MptL/HpWIplgW9ZcsKvvmwvGGBPhf0iMf2u+ZsZoG2PbkDkVnK8N8ceR7FGV+xv9Yk3Qw/MmbyJ/jHcxKtvA/nhB4MW1EPbHC4RX+eM4sqotdGq7fzyn7bbm2vPabrUmqOrhuLdsAfJ70EPbmAeebaaD/ynDH8dZR232abvrqO8w+lT1kdWneddRUaaLVM8XY/FvIwKe/THrhNKzyHZq0Rp7NwvaWLd+IdAfd2cOU/tj7Cf2x8o+IHxe+8D+WOlZiWSCbVn+GOfgFbxvDv5XDX+s7vCfMdrGOT3LH0e+R3GB+y9vHPmhnDlcETGalcOFrI0hXdYaDNPlW7PxyeZ3jTUbhwPXbJBXt85ixXslogXXbNT6T0mUKdwXC+L/D401G6zPut6L+CjERv+fQBuNPid9yvUo/PR8ncmy0ayjeW10Vs7ENtrBfzLQRltrXWij3VpXL+ddQnTzH3LG7tZ+udB+t2J3tZfuooFH2SFea3cxpG/t2BcDf96I23uxnw/707ef74tGfxa9n4/7E+XO+/mQXmvvncoPEGdZtIn+C+vNGfyo9yOw3iw3vo954LGPEH6ykdwr/10TvKCsOEbN0l2mwcHPAA3sQy2frWRdM+hbyqCP7Y6DPxhIH8+LoqxijLtloFeNO1+fHwV+LB9fBX7Sp1yPws+28vFoz9nHq7Gu7tVlOSE89g37+GUoW6S28u6RxTERknM4+OvFuFT7BWtEO44RZ1+y9tbO7IEc7bzQaavPrqUcbdGw8ddCjvZQw34PYo72FYH2e5ij9S5He7Rhv9vJ0dz5uH7P0Z5o2OFrPUd7ptCJfs/Rvsroz2GO1nxi5mjP7YMc7ev6PEd7wR7L0V40zNH6PkerdzFHey2doRvEHO2VwxzNK5vvv8ZztNfssRztR4c5Wt/naG8tOEd77IDkaG8f5mjeHO2/DWCO9p5hjrYD26sc7Vf7IEf7jT7P0T68x3K03x7maH2fo/1RF3O0mwbE//9FTv/fyR74QfP/fzuA/v9TOf2/lVcP/f8DT17//8994P/dQf1+9f+VQPrwPB7Lqp/8/xTwM/T//en/j0Afsf/Hs/pF+H/3zsrI52JX2K7knYc9LfTW6pfY87DW2Tlnk1TbCrfPbqVtqHNs6e8bje/VnE+NvrOujia23+NxOJJon8PwzJfPD2edLfS1r/oooTLlsw8bZb7+VHLBNhQtrg0Vg9xKvOA9ma7N/QDDZ3wj+ZoW3UAZKBvKdmxldjdfKyAnJW8+47ss8K4ADJ/xXSa86oxvL/yyuoeVaX5ooF92etMLv4xxeYhfRvi8ftnJTPllju2U/UeZh9z7oc4xsg96RKBf5ruJY9/lnHU3MeeNDv7RgTqH/KRPuR6Fn9yxoJXHp09Inqj6fS5p1ceLVKbiMPZFiKeTc698D42Df5rQxxmjPr5zvt/jvWfnjPes+Z5hvNd82KcP473Wetyfw3gvLN57UY/ivRcNYLz30mG81/fx3sv2WLz3ymG8N9Dx3n9pI977+Ua85/yQeg9Bv8eCr+/TWNC3PlEWtDCtSaJtG7bDdy5fNPBfT2WDFqdyoMqxyKDEqVXAj/3CMmZ7ZukKl/n0Mkm0nmDdc43PIfYg0l6AFe7b0L0ADv5nA/3YLcBP+pTrUfhZjb1PVa2HW/tULX1Xd8JbvkrFTuqedLbZvxwYO1U9+FAnUEcPefD9ymyTzt9vfI4cj5l6jDT79m38uuHXVKyTV0eQb77PHvUH6yq7pHxJL23ELYI2lu1v9dc692rse/uybISTmWUj1PjEWNKNKxVz4ruzfmp6N20cV+I45nZCbI7PBvyR2KvBsk4/H4D2/2RW4/bd0eqLUf8K7M+fUZvdyg/+so384C7KD0LmqZAPlA33o9r/oPYotOxnE3zMJq16y/EKzhnEsEUrQK+yscvEj4P/B8POq3kRax5lRcAj37w/EXPale7Ia92S18UAeX0up7xu6UBeF0lei4a8VuLIa+eO2lUhr5sFPRWCL8355aX4HzHktSrgkW/Oj1GWWBfruVwIZbtMsByD9EBvOx7nU6IfejinK2MOnBPjmMOao02fdm3RXNKqR4tUhr6G9+RasZDynw6vz+/49pjPQ/+9w4gfMD5x8YOaL2L/iXMDIes8kfKWKsvV904bXudx8OfmdvOFcyTWnBrHBb71JV7nWSS8ap0njqw6v+f9QYZtVvFUkfe8qxxP1eP5I9+YQ35D9rpa+6sd/K1izMU9u9DsU7WOomTG6yg1o0+LPrvI5/7Vnvp25yYR/jDB+uYqsZ3IdmrdGns3C9pYt7400B/jnEb6lOtR+NnMO09Y9ByQNU/Y6ZpWVs7OOauD/zdi/FvzhFn57Oto7iHrnUA3JJrvvO8Eut2wY3HW1ey7TZTsWPZPNOxY0etq/N5SFU/NCtp975TGe0WwrVONz72MC0Js07MCbRPOcaRPuR6Fn8XYa/Gd2CZeI8j7nq+s+TQe0w7+smGbUC9rHnxTidbR4wTvysYTfTbtIZ72S4H8q3wIYTjOd/BfD/y/rQ9iM+TbF5u9IGdslnf/iNLL2aRVn33nStNHnQG96ME95oH38f/vDD8U2xa2uy/pW/tq3kTbQmutxpoXT58i9yXxvEno+43wfYOvpD3g6G9jxO8Y++WJqV5pjGXlA6zYWMWzyDfPa+IaI++nUHt00s9lT9sKt2+eCPfW8F7ijcb3as7Htwccz7IrP+W7nwD31iwY8MwXt78YIJPEaF/1UUJlKjc+bJT5+tO332bUoMW1oWJejmtdm6Fzg5HudWjRDd/7NX0xw4/R3OAyyMnau8K2EfHinDLPDS4RXjU32K/zSG/pq/kJ7ffQt7Hfs2L69Gl3rkv5PZ5LV/YfZc4xsMrr1Vo3+6CfCcwBHN/duuNR5Z1qjzLnnT8XqHPIT/qU61H4yR1rFb0vxslM5Z28Z0bFWuyLEI+Vk2E8FrKvzsG/z1ij8u3HeTzt8VD7WVQcmvc8VCLasHwnlin8vKd5MYA2lSP52uC9y+rMUIw9zegTrft6HDyuo5epDQXPfHH7KwEyScRvak+zb93efffpCpdxn3K7rCdY91zjs7WHKXLctM59G3ofloO/p7/2DmzGjgWsfU8oM3UeLGR/QCf38vh858cD1yo4Foitc+3Gn/f2cB1TzZUxvUni90lO7mpOUPlDXJ+6fno3HOZuBwDuHyiXwRhR5X2zUI7w/zzXbPMz1Ga34obPtRE3zFHcYK3LZK0X+u6oz7vHtXSglQ+1Ns53rvdijTpkr+sY8BP7DADvdVQ2opdnJkLWzWZyyutCB/Ky7gFleUWy8YuWjb9F0MM2/rAhL8X/mCGvLBvPZ0xCbLyLKdU6QZK06nyP9LbjcX5a9EPv1nt1fNfN9V7242pdLWStVc0D4bgImQdSZyB5Hughwu/MGPUxflD+8wLRrPZKpJ99c9DW/q6SaIfnx2818FtniX20Dc8S99dZYp+ucBn3KbfLeoJ1zzU+q3klPHvLvPYinvDldF8ZaJe7tEdwoM4Sd2uP4GOF7XX0qTPz3dI59PXWOiGvkT3RiMlUf56H3/LeZc8xvxVn8dhXPsnJXb2HIGtv5p9P7YZDu4N597MO7OYR34Wk1jo473bwWweabX4VtaniBowzWHfxnUkK/lYPDZtG3KDqp+1/tCGn2aRV1r57IJIMuthH+fjw5d1fE5h3s93vRR4ZEo8//9rKuxcteZ0PkNe35JTXzR3I6zzJq9/ybnX3V8uetpx594Qhr6y8m/dW76G8u+Nx/rLA+A7f35Q+5XoUflYHKe9W92ywP0Q8OC5C8m6VD3Pe/Z8N/6nqY/yg8u5bPHyE7ruKc5ajmaM6vn259c0eOb2O4hvc28dzodiOg886C8r7rmqEV+27iiSrLaa54uHRd+7ljYZtVuderPg769yLo8c696Lq8XwN/6b4Dcm3LggcLJ+7xJjr5fvBQnKqu3uYU6FMF6ge0o42k38bEfB8JpN1QulZ5LG3aI29kLsc391f8+BLyh9jP7E/VvahiHfNzCV+PSuRTLCtTt4x7Jvrfm/gfIvjO+u8wWuNfNa3jhzqjyPZoyr3t2//G/tjB/+b5I9x7lnZBvbHWfuv2R8vEF7lj2PvSW3Xdn8kp+3u5N2OIfNhWfPzli1AfkPO4al5epbP7xv+uF/vvfjDnPMFRd57YZ0x8cVY/JvKj9kfW/kxrhdEtFOL1tgLeq9qf+XHS7H3g2fZB/bHSs9KJBNsq5NzyJwDO/j7DH8cev4P8+PvC/DHvby7ICSO/KecOVzs9wGGzNUjXeo83AUPXWMeeJ9sSg3FQ31hncX7E5DXucZnK94rES14zv2CaKskyhTuiwXxPwH88ztb1Rm8XsZHITZ6Bvjp13NiRa5Rd2KjWUfz2uisnMk3T3lMjDllox3fWTb6zoaN7vf3sp8Rumn1exl+a7ffrdhdrbFdNPDEfC/7TUIn+v297OeN/iz6TMDwvexNnhB+2fDfNcFLjPeyrxs+1PLZStY1g75238v+5YH08bxov76X/eGBPh73OKVPuR6Fn+F72ZPWMfE4w8er/VCuTK1Tzxh4U7qevQdytKcbvuRaz9Gec43naFf2WI72dcMcre9ztBcXnKPtH5Ac7duGOZo3R3v5AOZorxzmaDuwvcrRfrAPcrRX93mO9vo9lqO9eZij9X2O9lNdzNH+qtHBg5yjvXuYo3ll84vXeI72/j2Wo/3GMEfr+xztdwrO0V7X6MR+z9H+YJijeXO0PxvAHO0vhznaDmyvcrT7+iBH+8c+z9E+t8dytC8Oc7S+z9GmDj3wtxs52osHxP8fBJnE3gM/aP7/hNCXfvf/1xn9qfy/lVcP/f8DT17//2ChNyWBI6b/vwVo6Ef/Xwukj+9R7lf/vyLG3dD/95f//0rD/6u7yDrx/9eT/48zD9u8p6LdedhHGf6iF/Ow1tk5Z5NU2wq3z27FuPvP966jQbv7j9tXfZRQmfLZh40yX38quWAbihbXhopB+A4q12boGd9IvqZFN3zvI+czvg7+0qHdfK2AnJS8+YzvssC7AjB8xneZ8Kozvr3wy8ijzy9fCfTLTm964ZcxLg/xywif1y87mSm/zLGdsv8oc/bLuN6j4H0+6IWBfrlLdz+ZOZiVNzr4FwfqHPKTPuV6FH5yx4JWHp8+IXmi6ve5pFUf+V4oFYexL0I8nZx75XtoHPx3CH3MumPy0IDEe/8xZ7zXybu3h/GeP67hsTOM95rPMN7bDf/mHsV7bx7AeO8nhvFe38d779hj8d67h/HeQMd7/18b8d447cFU7+Lo91jwA30aC/rWJ8qCFqY1SbRtw3ZuIdiLBv7rqWzQ4tThO0n8usJlPr1MEq0nWPdc43OIPYi0F6Djd5L8SaAfw7v206dcj8LPQL2TJO/7FFXsZL1P0cH/dWDsVPXgQ51AHT3kwfd3h5p0lhtJXi/vXkeaffs2/sHwayrWyasjyDe/ew71B+squ6R8SS9thLp3nWX7+f5a517t9Xvc+V3tykao8YmxpBtXWe9F/fzEbto4rsRxzO2E2ByfDZhq0Id7NVjW6ecD0P6+wxq3745WX4x65HCzzVlqs1v5wSHgPzQ/+Eyjr/LMUyEfKBvuR7X/Qe1RaNnPJviYTVr1luMVnDOIYYtWgF5lY5eJHwd/BvhhO2+95zt9eJyvCHjkm/cnYk670h15rVvyuhggrxtzyuuWDuR1keS1aMhrJY68du6oXRXyulnQUyH4Ww15Kf5HDHmtCnjkm/NjlCXWxXouF0LZLhMsxyA90NuOx/mK6IcezunKmAPnxDjmsOZo06ddWzSXtOrRIpWhr+E9uVYspPynw+vzO7495g8z/Keqj/GDmi/yvVsudJ0nUt5SZbn63mnD6zwO/naKb3COxJpT47jAt77E6zyLhFet88SRVef3vD/RsM0qnirynneV46l6PH/kG3PIb8heV2t/tYN/phhzcc8uNPtUraMomfE6ylcZfVr02UU+96/21Lc7N4nwhwnWN1eJ7fTynfI3C9pYt54b6I+7c55dv1Pemicseg7ImifsdE0rK2fnnNXBf5MY/9Y8YVY+ey/NPWS9E+iGRPOd951ALzXsWJx1NftuEyU7lv23GXas6HU1fgendbcJ0s7vP3Jt4r0i2NapxudexgUhtukVgbYJ5zjSp1yPws9ir9+7adkmXiPI+56vrPk0HtMO/vsN24R6WfPgm0q0jh4neFc2nuizaQ/xtF8K5F/lQwjDcb6Df42YT+1lbIZ8+2Kz1+eMzfLuH1F6OZu06rPvXGn6qDOgFz24xzzwPv7/X8MPxbaF7e5Luquv5k20LbTWaqx58fQpcl8Sz5uEvt8I3zf4+40YaTJp9bcx4neM/fLEVO82xrLyAVZsrOJZ5JvnNXGNkfdTqD066eeyp22F2zdPhHtreC/xRuN7Nefj2wOOZ9mVn/LdT4B7axYMeOaL218MkElitK/6KKEylRsfNsp8/enbbzNq0OLaUDEvx7WuzdC5wTj+t1U3fO/X9MUMH6a5wWWQk7V3hW0j4sU5ZZ4bXCK8am6wX+eRPtpX8xPa76FvY79nxfTp0+5cl/J7PJeu7D/KnGNgldertW72QR8LzAEc392641HlnWqPMuedfxqoc8hP+pTrUfjJHWsVvS/GyUzlnbxnRsVa7IsQj5WTYTwWsq/Owf9t4B4P3I/zBtrjofazqDg073moRLRh+U4sU/h5T/NiAG0qR/K1wXuX1ZmhGHua0Sda9/U4eFxHL1MbCp754vZXAmSSiN/Unmbfur377tMVLuM+5XZZT7DuucZnaw9T5Lhpnfs29D6snbubjjzwt0/2DmzGjgWsfU8oM3UeLGR/QCf38vh85wHoI2utgmOB2DrXbvw5L3TO6s8i1zHVXBnTmyR+n+TkruYElT/E9akXTuyGw9ztAMCdObKbR4wRVd43C+UI/+AjzTavpza7FTfcKHQ3K254DsUN1rpM1nqh7476vHtcbxV8qLVxvnO9F2vUIXtdF4wxWPT6L+91VDail2cmQtbN1nPK60IH8rLuAWV5RbLxi5aNv0XQwzZ+I6eNHzPklWXj+YxJiI13MaVaJ0iSVp3vkd52PM4fFRjfdWe9V8d33VzvZT+u1tVC1lrVPBCOi5B5IHUGkueBnmr4T1Uf4wflPy8QzWqvRPrZNwcdcpbYtwaBZQq/dZbYR9vwLHF/nSX26QqXcZ9yu6wnWPdc47OaV8Kzt8xrL+IJX073/EC73KU9ggN1lrhbewRfYuTd6sx8t3QOfb21TshrZN9mxGSqP8/Db3nvsueY34qzeOwrn+Tkrt5DkLU3c5HybmwD8+5XUI6s9g9gXc67HfyrIO9+JbXZrfc1/afAvBvfyXTOmK/3nSlJMugKHYO+vaI/ZOTdPZhvXWEfnXef2I/kzIti7xPrZR4Z8r6GN+WU1/kO5BXyvobI97vtyEvN518Q9PB8/l2GvBT/1txq1t1pF0he1jlLjGlZtjzv6osxu6i3HY/zdwxAfNfNPRbW3kLef6HWNNgfIh4cFyF7sBHeN9/7Pwz/qepj/OB08wjAxbAR80D7KPCcEP4Kwb/PsBGuTgJtjsJv3O/zAv4IwaSPsxHTUDZP9eahDOHKnrYV7nnBv2vD9ctR+n2j8b2a8/HtbzwGNJUFXUdJPm5fPub7xwx45ovbPx4gk8RoX/VRQmWjou5ho8zXn0ou2IaixbUxK36fIV5cm779jU4/nW7gGYkY+xtdv6IMjgt6KgT/B5RHnAQ5KXmX6PMJgfckwPD+xhOEV+1vjCSrFaa54uHxuIfmPw70vU5veuF7Xb/eTz/gRb6SpMk3wrMNPiHgsW+czOYIXtlqZf9R5uxfnQzHPPA+H3SvMbeCY9jxrWx3DJ1DnVI+5yjx4+D/LlDnkJ/0Kdej8CN1Dm0565yyvQjPOqd0VPX7XNKqj9NUhv09T3imBR60bayPDu+YB961VyH4zxvxnqqftn9f4/Ns0qon7IccX6F+CP1/DD/k+gr9wTFBT4XgxyhedLYE/dC8aIf1BvGiPWI/dJzwKj8USVamTUAej3longKaOc5Gex4SZ1s+Aelxuqj8pKqH4z7EFqgxt9NHiR3XsXwOgnzeMSCxxbzRp6qPrD4N9dsqzj1B9ZB2tNv824iA5zs4WCeUnkUee4vW2CsJ2li3zop+Uv74CPCTPuV6FH6W8vpjZR/y+mNlz5U/9uWX2Jblc3d8QxI2D+Hgz4vxb8UEM0bbKe6PNz473ZwFuBg25DDwpfjm9SEHv2DYEFcngTYr8Bv3+2EBP0swSdK0IRhzHKYyrDdj4CmLthgn9kvZwM1x2EMNnxBpPm2nP9udT/tyoz9jz6eh3DnuQnrLAp7naw4LXktQF3/HOyaw3pzBT1m0zXqDtkTBYx8h/COF3pQEDjVfxnF4lu4yDQ7+sUADv7MZ68948CF9swZ98xn0sd1x8E8MpM/5wsmkVVYxxh3Gh2rc+fr8aYE+fj/wkz7lehR+ZM6N9px9vBrrCM+2ISsudzKbI3hlQ/aLtlDmefNqztsc/Kbh4yeh/izRjmPE2ZcZA29K1wcbn53eVgCuW/4feaqQTBz81xr+An39KMkifUL8P/Lt6JlNWmV3OPHjLgv4kgf3mAfex/8LhE4o+mY9+JC+ikGfsuMVwT/r7IsMX+Jw4D1gyv/NeXjAz44W9KUl0VZJlCnclYL4/w+Gn8D6aFfZxnQrPsPx5ovP7gz0ExXgJ33K9Sj8SD+Bus1+QsWQCJ83hnT8zRG80tGSaAtlzn7CyXDMA+/aqxD89xp+QuUNM0bbKe73ND7H7MvVtQfmU++XTb3JF8b3CeGvEPwPNXidAj7c307Wpq+sbtauLG5e2Vze3N5e2to8SO2nj9Ob1JY5OzVWb5bj2Eif8cZ3N3fL8K69CsH/SIPHtF9eR+OvIvClcD9pwJU8f+9vQ/xWru/+bbLeCj9ab4V3uKfqrTS6smkow3GbPvsa31Fe2Jajo0Lwd4HNTZ8JqOPqzwn8E4R/F93iN7Qb3Nao+M3Bp/3zJtJb5L1AW1lDXZhOih8nC2trK+sLl6pLq9tbV7aXFrPGSdH4L6+tb1fXr1zerNVqC9vVy93Gv7S8ubq1uVqrrS/VLi/VlruNf2Vppba2trm2tbJ1ZX1p61IW/nJjAW6SyorWu0nBZ1Htr1VXVyeT3U/B9C+6mGwmSvsLa679/XHor4432nl4vdk+8uLwjhIc10GY2wDmNoBB+/xIgHmkB+ZRAPMoD8yjAebRHpjHAMxjPDCPBZjHemBuB5jbPTCPA5jHeWAeDzCP98A8AWCe4IF5IsA80QPzJIB5kgfmyQDzZA/MUwDmKR6YpwLMUz0wTwOYp3lgng4wT/fAPANgnuGBuQQwlwAmAZgrAHPFA/M8gHkewfBcSfq4ceHGbgzbuVZdWopsGxYdbzgvshPbJa15d5HreCExJ+KfSmLa4WqtRPgcPSwf19cq7+Wycr2VD47DsX/TnG281IRj3XJ1J4H/omVxVe9WI+vdSg/1bnUv6t0olZXrrXzk1TuUCetdOYIsrurddmS92+qh3m3vRb0rU1m53spHXr1D3WK9i7EOsVZdXh/62cHSuwqVleutfOTVO9Qt1ruxCLK4qndbQ70bLL0bo7JyvZWPvHqHusV6Nx5BFlf17kpkvav1UO8WBl3vnHwOxKGn6to/GKl9x+8hwS/q8wHiN9KaZ02tC7IuRtqXE6yLDv8U0RpLF9W6ploHjX2GoltnBdX+8EOAk89GnYpDz44/Pgn0sC6ejoM72B87/FNEayxdPJ209g3Kx/LHJ6isXG/lQ/lj17/oj0tUhvSoM8FzSauuoKzQpmFb6PcOUltoA3l9Hm0nxwkTUFZcnLCyMIwThnFCL+IE1OdhnND8269xgrLNh6isXG/lQ9lm17/KNhdpT1HH2J7imnWB9nRxaE+H9rQX9hT1eWhPm3+HeVec9h2/w7xrmHehbx/EvAttJ8cJuIevwDhhZRgnDOOEXsQJqM/DOKH5d5h3tdLTrj1FHWN7infUFWhPV4f2dGhPe2FPUZ+7ZE8Xe2hPg2PdoT1tpadde4o6xvZ0H5QVaE83h/Z0sPat7KOycr2Vj7z7VlC3ZgDuIOm628+HdJcE3XH3+K1cirmXq9qwu/fzWG+2b+2P5D1sKPcxkOd4gDxHui/Py3tZnqNdl+dqLbI8V2LLM+7e8Ob4jXQXydYhQT/iSp/xerLzjJI8UUY79hDhqQzPTpfru/G4s8V41gnbcnRUCP5AowF1Bt3VnxP4xwj/LrrFb3gmhdsaFb85+FRvphqV0rgl1Z+PNRJCPmeZPhuNv9UOH+ez8K6eLsUTbe+DjRVbWfEEygfjibRsTtA6J8owDsIyxDMn8HSrLXXfG98LpmQza+BRd4bNiHqsc0hfL2JYh38qiToGalb/Kbk62R0QtM6JMif/2cSvq+3q0KygYUbUK3n+Ojz8m6Wrs8SP4rVEZcjPAQMP1j9g4JntEM+swDMj6nUqN0Vzt8Z4ZN8RtJcaaXXw6i6zQ4accG6M7zKz9mcVgXtc4J4lPKr/JgLpUv3n4GZEvU710aJZycbqR+u+KiVLlPORANwHC8Q9LnBHnnvdyZkizR8uVkiu39ro+DSOfVLj8wzIjGWTwj2ltFuuTod8d3TyXXIO/hmA++nw+c7S7n5AHXW6qPTDlUWeE965f7zdu0n/bQMopffPpnbLUs3ror1inQ6991O9h+LogMjrck55jRcor0NCXkyv+46ydfW69b63LNn67ll/vpCtdR6/G3fh/wXQwfpfAbw+m553vKg7tNU9uawno6ItlHnee3LRjiL8S6CPPj+1mz70zbiu42sb7XeWnf+2guz8O6eabdYNO49tcTyDsnZwMc+UVnPknA7/VNLqr2LknONED8uHc84JQavSH9Z9zuXTR/XVAWpD0Tcp6CsRDQiPfcpxmYoHrLamDNyTAn7CwI108f3Jey22nxI0W741a/8VyxL3IR4KwD1aIO5xgbtCdH0AbNUbyWaOirZTuDeTzZyEtkdF3cMe3D8BuH8cPn+YbCbKkGPjKVHWrXhkPoNv333Md4Ov41hP+XprbGfddcw2DXVwfkDk9c6c8hovUF5TQl5Mr/uOsnX1JkVZL2TL49/B/4KQrYqN8Z0Y6VOuR+FHxsao/xXAm2UT0yek/7lv0kfdDc4xtPKrKHOOjR2eMQ882lGE/1XoIys2dnzPGG2j/c6y8x8syM5/F8TGHzLsvIp5lC42qsXWxQWli2hbWBetGC992o3L1PtCWE8xPnU4VRzL8U9J0FASNM956qfPjKhX8vx1eJIMPBbNKvbeJ9oK6ReUc7ux97SBu4jYm3PN/Q0k97/zLXAs/yWNZXw3SchYdvB/DeP3Xvh8eGQ3H+q9JCqHwLGMNiyWn5zO4HuK+Hbw9wk/WaI6SZIErbWod/oy3ygvHPfTAyKvz+aU13iB8poQ8mJ63XeVW8Q8T55Htjz+p0lAWTFbl97nImM21H/2k5ZNBPbM/rd8Ie6tnqK21PulrJgN4yYFz+94cvDT0Eccs5Wgvm8OENtG+51l5+dGdtM/AfSF2HkH/2yI2Q6Bvwmx81Y8EHk+M/ieYJ7PLMWhx5zPRBrbnc/kvVZ55+CGbXXelordSvRZ9f+4gUfpqspBSp6/Dg//xngUzVk25kJBNuZfJptt1gy7wvkM0sz2J6+cFZ7Ycq4QPyoeblc/Ld8Sa069RPxMJn5+lO+fDORnkvjBep3yY9Gs4g/rndT7BDzGJJzzYYyCZ34Yd6c8qrgoch6xzGfakk7aru3+yvtxO2i7xj9k2cDHkw108y+heZKD/wjYwCcZNtD13SjVZ7hyonUO924mog0fPsah8M9R2aEA2rC+msM95KEzbUOtV3TyDi7ufSePeaCpLOji+WC3j2Ik0e/ZZnjmi9s/GiCTRPw2kuzuF5Yx0uK++3SFy7hPuV3WE6zrbMCsKEPbfn/9eiv+yHnsqspjURaV+m45KL1Ve6tZnxBerRlZaw/KX3F/8byBuiOf89UXNIiN7A+q/H47xKXsns9GJYnti9W8OJ6N43qOnshzP5slwuf4YJk4/FNCJjHy08lAufKaHNadE2Wcb6m5P7VeN2xr2FaetlTuwblh3txDvUc+du6Bc7YR7fBKVnz7gxTftrsO8MMQ3/4wxbd4Zpr3mU0LmTAtSdIaZ6SP1Y8OLnZ+5XsXPdI8JtqyYgWMH60zJHi/CePulEdr/3ekPS6rWbr6FtLVdvfCfC3o6k8aunoE5IX1GQ7zHZQb9m0i2vDhYxwKP+diRwNow/pq77hvfzjmYsfo943G92rex5OLHQeaXK6EdCH+9J+76xJzseMGPPPF7bv2LJkk4jeVi/EZi2P03acrXMZ9yu2ynmBdzsWwDG3k/fXrrfgj52KbKhdDWVTqu+VgnXlJH7avxwU89qmzEXOJX3eU3ef+Qr/J/cW5mIP9dcrFItlVmYs5XMru+WxUktg+TeWzY1Q2KfCou1U6si30WLFczLsNrxq5xRLhczLE3xD/lJBTjDzQWmtPnxGSTxzdrC2UqH2k55CQD8c63Hc4vjEuUPHMSNJqD9C+8PmyexpCUTHSGNGg4kD8zck3rfc7FIOo+TKr36yYWO0pih0T4x5i7tuNxt9qzocn7iPvZd955+jROO0vZMW6H6dY1/mi0D31Dv5miHU/QXqGdtr1317VwUj2dM2KM6y4RN29f1zQ7/oD49gTxNtxanujEN4WVpjWVL5lQY/DP0NlrhxpjXNvfrifdfinBB8x/OxJooflw/Ot6t58daf+CfiMZYjnlMCj2hobtjVsa9jWsK0Bb0vFAfwOm8Lmr664Z+v+r659tsttt7/bnazE9Z/VTRWPunmDVL43jOr+8sWjJ6Ec4f92otnmTY0K1vmHvRaPqtib1xDUmsC8gQfr85oAz1Opvw5PFj+K5qw8ZoX0Jus8EucxDv4XQW/WSW8U/3ttj2KWnB9GckY5KjnzXl0HfwfI+RGjYbhvy9nHvIbo4L8McD/a6OMQ2fN+xILt5XZI3yL+bs3rqT2p1rxepDtOt0rUPtIzJ+Sj5vWw73Bs++b15oBHtle71hTot2c2Oq7oeb0nkw4jPzzGVb+ps67KRrAMsV6ntkjRnGUPNskeuH4JtQcO/l/Gm21uG/aA17iuFTk/vyA5/xLI+QUkZ7Vnfa/KOdZ9wc6GOJsb6V1KW2pOvFRY+4tbWfr47aSPWfszcC89wn8X6OOdOcY96irH1Hn3nmF9vm+Dzxarvw4P/2btceOYugi9V34+fTYaf6sdPmpc8T3csXKQOeIx0lzuJTXPXqAMa5l79GhcuTmG0HHl4H94tNnmezxtlpLWeWpuP/13EuhTNBwjGhz8axtAaaj/BXq3RKT3C+/EoqeF3JDvU0Szg38D0Mx3HKh5K3xnDa/7qPf6qnn9WZIb1p2k77HkdV2GvE6TvBz8TxjyUvxbZ+yuE/CnDXmhLK+jtnDcuHUslC/3v4P/eRg3d3vGTTmjzRFRhmuAPE7eDTjf7sGZJHrs8d0GWWP1hIeGd0E/fp72aKn6aKssv6Bs+XFo4z1GG8dztqHu+uE9e3xXdALfffK2xrha88NxY91DxPOmjrb3gT58IEAfKgXSNy/oKxEe1H8lT9WXeO/FBwLivLhzOrWFSUF/gfvQajzf9WHo0w/B59Hybllg3/AZKuwPzsFUP6t3yKsczMHNiHolz1+Hh39jPIpmXv8uAo9aI+IzYajvKcw9NLZUzKDOrXHM8ATIYT5Guo396WSh+pPXkvL2p8Kj8g4HN5O02pNO+wBpGDN45T18Kk5QvIbGCWzTrDgB8ZQF/LyH1jEPPNt0B/83wr+WqD7uuUF58TlRFccyfVMe+ni+AMsU7tMEf53g/7TBv4P/tMgFLN1Q+9QdXNx96rVFtU8ddbRS1zJJklZ9TB/W3zMCHvWS74g8A2WnqAzHksOp7B6u736R7B72mbJ7+6Ac4R8Cdm+k3Pwc4tNi+xqel4jlaxiPz9fsKzd/78TXzIKclzxtlhKd1/M8GY5lRQPn9Q7+UAOvyuvPEA0bje/Vzp6dPPWskBvyfYZodvBHgWbOU9V4tGL+swIe+d7pq6R1bLu6k/Q9lrzOZcjrLMnLwV9nyMvVQf5PGPI6J+DPGvJCWZ6jtnDcOP+D8uX+d/A1GDc3eMZNOaPNEVG2yy9Q+QXA+WAPziTRY4/z+qyx6pufuQX6kfN6VR9tlWVXlS3EnHzJaON4zjZUnshzLdgG5sO8J2kN+uTLqU/U/J6l11nzexyHKnmXCA/qIN8PkT5Knjgn8+WGzDg2c2VfCTJ58TAfLQRPO/no7QXFCJ8aa7b5BKM/h/noA5+vxXz0q4VfYDu4l/PR54oYdpiP9iYf/Saye+3mo/8T7N6Lcvq0ay0fvaMgX/MdIOe7epSPvmIA89HvHuajufLR799j+eiPw7h5dZfy0TcDztf1KB99Yxv56B0F5KN3FZCP3pUjH8U9WCofdeV3Q5/8DPWJ2k9t6fUxAY90WPko353j6rWTj7q6yFPI+rcr+1mQyV8ZMud8FHmd9PCTJK2ySR8rH2WfGmvvaLfOmXA+6tuL9l7Sx6x7CThGcPA/BHHZr1B/lqG+k4Xqa4TjMWXtg5gT9StUNiXwzNB3V67+Ohr4N4sGzkeRV85HQ+/xtHQd+5/tAJ57mKO2EE9ZwM97aB3zwON5IYT/bSMfdfUxH0V5cT6q5Mz0TXnos+7iUrh9dgb5nzT4d/D3GPmo0o3evRtI56Ooo5W6lkmStOpj+rD+HhDwyo/NETz2l3UuM+v868fJ7mGfKbvH+aiDfz7YvU8YPg31lc/CYt/zO/Py2kCsz/vPsV6ndk7RnOVrPkUyd/3okzmfaXTwXwYy/0dDzo7GkLhiTPDDdCZAp3VfGtZnP4z1Ou0DRXNWH3yR+gDvHA/pg533ZEEfjDQEq+TcLf75zhof/xOV5u+d8P8PlWab08S/isO4/myjjrorr8CcXN4VGBobHiBZtTte/zvI6jDJCuuX6DPu3R0Vv1nnuUc9PCZJ53qnaFbvbOV3NKkYT+Fxv6szTqEx3pRB10QAHouurPc6Ml3qfoaE8IwJHiYJx5iolz4h762LdE47+L11GJMqXd0ohp5aXl3L+14A7oPhPffdb6tTO9SL8R5ih6Zz0lXE+7qSpJUu5oHfuYVja6Pxt1pdqnbyMC43x6jsYUJligemuSRorq2vbF9e3NqurmzWltYuLS9fXtu8fHnp8vLl1e3qwvridq26uFqtXlpYvLS9uby1vrCydGV5vba+tL69tXJ5/VIIzQ5v7PivS+9FW+L7hZMcbWdpiJMR6jnmrI+heAxz0lFRl+8HcPBPhnjscRSPsV9KHxUncr9iPZ5fQ5pcbjCd6HsH+J2RM6LM9cEs0brR+F7t7Nm5J1Pdv4C8zEI5wj+zwaRax3J1EmhzBn4LmedDvkdIXph78lwrypLH4Sx9x3ZcvUlR1gu574dyhL8k5K7m0PD8WfqU61H4ke8lw76uAF7kK0na1w3sG2sdYpbaUr5U2SGmdcwDz/NlDv750Ef8fm2MU1jn+nWsf9MAjPUJkiXqQQxZqndqjghaKwT/7w1ZKtlYssyaX2ZZopwPUNkMyUvRVUrCxo1rG8fNQUEXy+Y7QDa8/yXSeyZ2+hPndZQs+b08Dv4VRn+q9wNY/XlYwCPfrP+4XoB1Ec+IgOX5CX5H46xoh7+7uYz9op3RjHYsnetlf2N/+Pr7BwL9L9r29CnXo/AT/b2gWTrJ/vcwlPH6llpjD7Hl/aoLb+zi2LdsuW/scxyD9boVc6DsQmIOB39XzpjD0mHVF6ExB79DeBZwMCzPXeyn7zOinV72g4qVuR/e0cV+sOK7rH5AWPZvIeMhobIRT90kCVubVHkCzm/MiDZwXeo9AWt4WNe3hvd+mAf5Jc9aV5LotS6O63BPjIL3rQO+T+RDM0Z9XJdT860hazuqXQc/ncGH732hvyH4mCUY5b96MZeAc4O+uYQPG2Nb5enqfnKmAeGRb16rU3csRZbXoiWv0QB5/W5OeZU7kNcoyWvakFekXHdHXirXVXvtOJ/7w5y57oghr6xcl/chqryE6XU2HmXLPpt9SQ/0tuNx/vHAnAXfP5U+5XoUfmTOgnNzFcDrG1vqXt68tkjNGU5TGfoavttbrT/juGD/6fCOeeDRxyP8fYb/VPUxfrD26/A6Tyz7odZw0N7ye0gd/GcN+6HWUSvwW951VLa3ah018v38wf6J550d/BcNeSn+9xvyUmOI+UZ5Kf/koxdly3vEpwQ96p5ta33UGp9WfKvG56igg/mYbBCRFd/i+JwIGJ9KJo4ufsdjkkTXzyqPPXxPt9INjp8Pj+3mC+cLlT/zzUMjXpzXPEp45whv2j+l6a7IaivUZ/vG8jGgOWQsW7YvayxzbK7Gsqqn9rll7aM56KFtzAPPvsHBnxVjrlvvB1HxsJIZx8M3GH2q+sjq06x4mPckoUx5nh5px1yaf1PxMs/LWPEy71/pVz96QfRTD+PlJRUvYz9VAK/PPqj9d3l9vRUvt+tzs+Zi2Oc6+HUx/q2YIMsff5HOWKizXszjoPvjRwT440nRTqf++BFd98fNd7Yrm6DiS6b5UTn9cd65H/WOl1j+GPkN8cdqryvL54ld98fNPm3XHz81pz+2+jSvP0aZWv4Y7Sn/1qk/Rv/Vz/74OYH+GOc10qdcj8LPUt5zo6Hvt4vhj/Ou8WT5Y17jcfDPM/wx+k/r7Cqu/3zKuC/B4Yx77sX2GVaMsrNvzrAvRZ+F5/kYNT8fch8B0mWde1f+QsH7ZPPvhb6UCAeek0derXPyTJ+jBc/JV0RbpUTLhnGPFcT/ncA/n5PH+qzrvfClqOs+X/qKvrLRvT/bzzYa42LW0Ypoy7LRaCcVvGuPz6h+v2GjQ+8XqABud7+A001+H9dG43u1s2dn3kXdp4e0+d4J9BrDDhf9nhy2w3gfEd9TivUmDTxl0Rbfa+rubRrzwPvebf4mI27vxbvNsD997zb7caM/1d3Hll/NuvuY+1O9S6wk6C0L+JOER71zC/0O/o7+S91hqvhR95Sy3qh7R08JHisE/9OG/z4heEFZ8R1dWbrLNDj4dxo+FOtPevAhfScM+k5n0Md2x8H/t0D6eB9BL96Rh+PO1+f/I9DHHwN+0qdcj8LPtvLxu95PB3h9Y926hy7rPmT28Xh/Id8frO60s3w8jgkFz3eIOvhfN3w8xicniHYcI3xvucKbonkv5WjqvuG4Ot2MW5VOY5zl0+mPGL6k6PuzHT3W/dkhd5hn2fiTHrry2vjfN2y8w4E5GvJq3a3N9OX1cVimcJ8qiP8/Nuw31mddRzsQQ9fxLlal69cRPw7+zwPt9yngJ33K9Sj89Pw+cCezOYJXOqrifpR5iP2uiPbZfv9dYI5m3UmO7079JsrR4uhmM7ZoVzc/Y9hh1e9Wjhba77NJq+04Q2WWT0c8yg7xOxHONr6PeeB9d2x/wcjRzkL9GP15DmhS/XmWaHbwI+NNmmPfc839iXI/l2jcmKOpO6lHk1abgDjLok30X1jviMFPWbTNenN94/uYBx77COH3QR983jOmkBeUFee2ZwUNpw0aHPwc0MA+1PLZZwV91xn0ncugj+2Ogz8SSB++I4NlFWPcXQ/0qnHn6/MTYtwpH4/vZU+fcj0KPzJHQ3teAby+sY7wbBuuF/DYN+zjr4eys9RW3rvjXX2fj+e40sE/SIxLRx/GHdcR7ThGnH3JunP+9j2Qo10wfMm1nqOtGDb+WsjR/pVhvwcxR3tYoP0e5mi9y9FuN+x3Ozmae49xv+doTzHs8LWeoz1b6ES/52hfPczRdmB7laM9rw9ytG/o8xztm/dYjvaSYY7W9znad3YxR7uH/D+uDcfQ2+PAc8jaooP/HsNfqPVNa9/FcQHPfKePG+f4fp7jVKbW0hWesmiL1/rxHdRlA3eF4H/Q8P/9ui/q1UZ/qn1R1hmiIvZFlQS9ar/FccJzXPCKPgl/R/+P9Xz5a5KE7RFRe1hUPs25xJsN/39M8IKy4ndWZeku0+Dgf8Lwr1h/zoMP6Ttm0Hcygz62Ow7+bYH08Tl9lFWMcYf7vdS48/X52wP9/zzwkz7lehR+pP9He87+X411hGfboPbkcd+kj/KhPK82L9qy9tHgmFDwrj0eE79g+H88i3GMaMcxYr2vZx7o+nby/2iLCuznlZLgWcnkCMnEwb/P8BeuTgJtWnfBqX5kvtNHvRNznur5bFTZ07bCPS/4d22ouCz9faPxvZrzqdF3JxP0a3lilZFE+zSGZ764/RMBMkmM9lUfJVSmYr1DRpmvP5VcsA1Fi2vD8h3se0PP+EaK8Vp0A2Wg4iuO2f9gfDdfp0BOVtzNth7xon3mM74nCa8649uLeNjar+vg/3gA/DLmM+yXVcyO8HljdvZt1nqPsv8oc/bL6P8UvM8H3Rvolx3f3cqpUaeUz+HY1sH/XaDOIT/pU65H4UfqHNpy1jllexGedU7pqOp3tSY5R2XY35xrqPNcVpzo8PriRD735uA/L/Rxxqiftv/8AYn3ShNN3kLiPWu+ZxjvNR/26cN4r7Ue9+cw3guL905M7OarW/HeCbAVgxLvXSfs2zDe66947yHQR3sh3rsQqHPDeK8/472HCn3Mivc2GwXq/g2+gwf5ihELol6GzIc6+K80YkEVX1mxoKVDSI+TlxpXIXEc08K0JonWJWynQrBHDPxWzOOjLSuu8a2nYJx6nH7faHyv5n0oUOUxjHGqWo9jP4Nx6gkDnvni9k8GyCQRv7n7sTA2PEawx+m7T1e4zKeXSaL1BOs6OxZiDyL5sRXLj1l7ARz8MwP9WAX4SZ9yPQo/q732Y7yGZel7RbRl+So8c63gXXtss7eN2AnPe8978Pn2NU158H3NRJPOb2t8VjaqW3qMNPv2bXy94dfUHpW8OoJ88x5IlaMwvUni9yW9tBEVQRvL9lv6K7+SNgLzmBAbgfB5bQTvc1M2Qo1PjFXduMq6m+m20d20cXyF45jbCbE5PhvwndDnX/DIOv2M77p6+YTG7cutfDHq94H9+Y/UpspXLZs7n8G/L1/93sD8APv0YZQfWHfXKJuk5lFZJ8c88N79bIIP696qyHdG7dgidWcU2ljfnVGvMey82p9i7XXPujOK9yfiPMrp7shr3ZLXkQB5vTGnvCodyOsIyeuEIa9IdyPt3FHb7t1IbzHkpfgfMeQVeu+QdUaR6XW5EMr2FMFyDNIDve14nL89MObo0h1VMubAeViOOay9cunTri2aS1r1KOQOKPbJiAftCPtPh9fnd3x7zN9j+E9VH+MHlU/7cptBX+f5tR6t8/xa19d5mmdq213n+aBhm1XMbt37GrqG4nQRbdZJox7ne/xbyBoL7q9W8BzrOfiPijEXdw91s0/VHmolM95D/XtGn6o+svo0a3+ydd7kFNVT6/GJ+G1EwPPd/awTSs8i26l1a+yNCtpYt/6kv+YJN/Pudbdy+vRp9xyMWmPtdJ5Q+VxrntDB/7UxT6jWJ7LmHlZo7uFUBh+c457O4MMX+33KsGO9uO9BxeV8pv4zhh1TeYA1/5h1pt7RE3KmXt2dwXT57hXhtfizUBZD9uca7fls01koR/gvBtqmXt61gX3KtukslI0K+Lxn9Nk2nYMyPu+eNabZNuH9LiFj2sFPNYSeddfGGQ8+PO+nch+2OeOJPst+zNN+KZD/s4L/g9QG8u/gDwD/XyCbdo7qbzS+Vzt6muNKnW9X9zbw+fYjQDPbNKWDls5mnR3nO5nOQtn1iR+3uqPhtAd33jsdTgmd7ZYtzOqzsx6az4o+U7bQ9VW/3Tt0FspGBXyIXp0FGD7Xj7p0jsqsO3+UjUv16YZGQeT10Z34PWud37cOcMEYy0Wvj/K8psrtrZw7/Vz2tK1w+9bocW8N32O20fhezfn49oBj/midG2c/hXtrrHvlmC9u/3SATBKjfWsNm/dqYd1DRpmvP5VcsA1Fi2tDrS1wXIv7lkLmBiOtRbToBspArQPw3Mhtk7v5wvuSlLx5bvA6gRfjK54bvI7wqrnBXtwtqdYvmObHBPo9pze98HsYa7Pfs+b/0yfv2pKTmXqnBc9PKPuPMg85i6/mP9gHPS0wB8A8Ten4RuN7taOnqXNZa1Q8d+ng/59Anetl3mm9R8Wa40qfkDUq1e9qjYrPJGB/cw6X9x0rWfNlvjWq5wp9zHpXyscbQlFnkXivqLXnV/kla565JNo5SrDzBn7e03w8gDa15uBrg329ms+OsacZ12LUWTrf+9Uw7rLu/1V396j163bXDdQ9I0yL++7TFS7jPuV2WU+wLu9pxjK+ezd2rpO1VuFbB7sj0C4fBX7Sp1yPwk/utQprvTB9QtYqVD6m1ipY34+KtjqxvRxjOvjvDowFeH2sF/k1jgFfbPOqnPk1vs85b37t6Ol0/7GzA07uaj+h8ocOf8rDW0Z2w2Hf4d7Q11Au4/JGlDPWPQzlCP/myWabr6M28R3pIbp7COhT8NMeGt4YGDfgO7h/kOKGQwDH62ZZe1w53213j+tbBB8qrunSWZZ1Hi+hZzId/N3GGMx7TiRrzwbvdVQ2olv7+tu9B/SdOeV1oAN58ZzgvCGvSDZ+0bLx04IetvH/vYs2fprkFWLjXUzpO4vIOt8jve14nL8vML47BPykT7kehR8Z32EcVQG8vrGF8O3aormkVY/Yx6Ov4ZzhkMCD4yLk7DXCo49H+A8b/lPVx/jBjQd8D/s00Yw6hHCY26L/VXek8D0JBwRdjEPh57x7PoC2Iu68OUq/bzS+V/M+nrwb1wTUnTSsW2ij1Nlghs+68+Z4gEwS8ZvKu3020X336QqXcZ9yu6wnWJfzbhUf9vvdAn/RX3Y59zlB626r9Gn3/oO5JFvfle21cpesmJ9tr4O/z8i71VnFbukczhOo8cE65+A/Y8Rkee+zUHMfyLejR91n4ZuLTRK/T1LzHa6eyifRHz6e8u4JgMO8+4uUI7s+RjljXc67HfyDppptjlCuiPUb1+jtlE2KsknBdwyd2id4tfJ7Bz/R4E/plJpjsPak7xPwzDfKC8/y7uuOvBY7lddsTnlVCpTXpJAX0+u+o2zZp/IZ6o3G92pnT7Au8jlsB39UyFb51AngJ33K9Sj8SJ+K+s8+Fd810e54Uefb1V1SPC82IdqyfKrD4/Oprr0KwV8PfcQ+dRzqO75njLZT3BdGdtM1mcHHRE4+Jj18PETwoewS2/hpUebGFfrwGOMK5zZZvxA/56AXDZtl5cHpwzqr5mtV/O7khTrL84goy7kAPBZdWXe1zhJuFW9Fvtt2kWn12UffHPZDjX60+qUdebHvUXGbkuWBADwWXVlxKfejiksjx/GLTKsvvvTF8Y8w+jFvXpYlrwmS1yEhr4TwuHkDNT+VJK1j0TfO+90uPi4w3pgCftKnXI/Cj4w3MEbgeEPZboRv13arNdJpKkNfz/cSKx+O4yIkFpkQdLEPf5bw4TNGfcwRVT5XSnaXTYqyfs9PLg3zuVzy+tphPtexbH353AsN2apcaRx+azdXCpHtFLWNfcSy7Ve9fWl/5cpLeXPlWLZI5crc393KlV9m5MolqB+aK8/RvppJAadsMeoA+/V+ym/+U878Bm1Ip/nNIOaDP5RTXpUC5TUl5MX0uu8oW4yluawXsvWtHb0+55yJ5busHDivbHkNFvuIZduvevvjgb4LfXH6lOtR+JG+C20L+65YtkjdX8L9nTU/mnffJ+dWDv7thu/CnMnxPWO0neL+YMPhzSZ+H6dsMfuuXszplACnb07n53PO6XQyB1YiefXbHFiIvH45p7w6WctmeVlzYNZaNu7l6IZ9zZIt21cH/+s54wLLdynZ8n6x9Mkzv8j9rGTbr3r7W4G+axT4SZ9yPQo/0nehbWHfFcsWzRG86u9R0RbKPGTPJcK79nhe955A3+X4njHavv/+8kZBzL5cXXtgv+H9sqk3+UKZJYS/QvB/2uAV40f3t5N9kVdWN2tXFjevbC5vbm8vbW0epPbTx+nNdAT8l9fWt6vrVy5v1mq1he3q5Sz8O3uC6s1yHJvpM9747vaiMrxrr0Lw98LeoE/S+K8IfCnc5wy4kufv/W2I38r13b9N1lvhR+ut8A73VL2VRlc2DWVoN9JnX+M7ygvbcnRUCP6zsLaePhNQx9WfE/gnCP8uusVvaLe4rVHxm4NP++c+GjfIe4G2uoa6EGOcLC1vrm5trtZq60u1y0u15W6P04W1tZX1hUvVpdXtrSvbS4vdxr+ytFJbW9tc21rZurK+tHUpC///Dzp0oe4COwUA","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"24":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/expressions.nr"},"71":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // let mut field: Field = 0;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    };\n    field_val \n    // assert that the conversion is possible, i.e. the bignum is less than grumpkin field modulus \n\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // safty: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n    // validate the limbs are in range and the value in total is less than 2^254\n\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // validate that the last limb is less than the modulus\n    if N > 2 {\n        // validate that the result is less than the modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, result);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(result);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        result[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n    };\n    assert(field_val == field);\n    result\n}\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/constrained_ops.nr"},"74":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_ops.nr"},"75":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_helpers.nr"},"79":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/split_bits.nr"},"80":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::field_to_u60rep;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/u60_representation.nr"},"85":{"source":"use crate::utils::u60_representation::U60Repr;\n\nuse crate::bignum::BigNum;\nuse crate::bignum::BigNumTrait;\n\nuse crate::params::BigNumParams;\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fields::bls12_381Fq::BLS12_381_Fq_Params;\nuse crate::fields::bn254Fq::BN254_Fq_Params;\nuse crate::fields::U256::U256Params;\n\n\n// the types we will be benchmarking \n\ntype Fq = BigNum<3, 254, BN254_Fq_Params>;\ntype BN256 = BigNum<3, 257, U256Params>;\ntype BN381 = BigNum<4, 381, BLS12_381_Fq_Params>;\n\n// macro magic to generate the benchmarks\nfn bench_add<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a + b;\n}\n\nfn bench_sub<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a - b;\n}\n\nfn bench_mul<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a * b;\n}\n\nfn bench_div<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a / b;\n}\n\n\n// type Fq\n// type BN256\n// type BN381\n// type BN2048\n#[export]\nfn bench_add_Fq(a: Fq, b: Fq) {\n    bench_add::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_sub_Fq(a: Fq, b: Fq) {\n    bench_sub::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_mul_Fq(a: Fq, b: Fq) {\n    bench_mul::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_div_Fq(a: Fq, b: Fq) {\n    bench_div::<3, Fq>(a, b);\n}\n\n\n#[export]\nfn bench_add_BN256(a: BN256, b: BN256) {\n    bench_add::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_sub_BN256(a: BN256, b: BN256) {\n    bench_sub::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_mul_BN256(a: BN256, b: BN256) {\n        bench_mul::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_div_BN256(a: BN256, b: BN256) {\n    bench_div::<3, BN256>(a, b);\n}","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/benchmarks/bignum_benchmarks.nr"},"118":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, from_field, mul,\n        neg, sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range, to_field\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct BigNum<let N: u32, let MOD_BITS: u32, Params> {\n    pub limbs: [Field; N],\n}\n// We aim to avoid needing to add a generic parameter to this trait, for this reason we do not allow\n// accessing the limbs of the bignum except through slices.\npub trait BigNumTrait: Neg + Add + Sub + Mul + Div + Eq {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    pub fn new() -> Self;\n    pub fn one() -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub fn from_slice(limbs: [Field]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n    pub fn to_field(self) -> Field;\n\n    pub fn modulus() -> Self;\n    pub fn modulus_bits(self) -> u32;\n    pub fn num_limbs(self) -> u32;\n    pub fn get_limbs_slice(self) -> [Field];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    pub unconstrained fn __eq(self, other: Self) -> bool;\n    pub unconstrained fn __is_zero(self) -> bool;\n\n    pub unconstrained fn __neg(self) -> Self;\n    pub unconstrained fn __add(self, other: Self) -> Self;\n    pub unconstrained fn __sub(self, other: Self) -> Self;\n    pub unconstrained fn __mul(self, other: Self) -> Self;\n    pub unconstrained fn __div(self, other: Self) -> Self;\n    pub unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub unconstrained fn __invmod(self) -> Self;\n    pub unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    pub unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    pub unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    pub unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(self, other: Self) -> bool {\n        self == other\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_range(self);\n    pub fn validate_in_field(self);\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub fn udiv(self, divisor: Self) -> Self;\n    pub fn umod(self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::convert::From<Field> for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn from(input: Field) -> Self {\n        let params = Params::get_params();\n        Self { limbs: from_field::<N, MOD_BITS>(params, input) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> Neg for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> BigNumTrait for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    pub fn to_field(self) -> Field {\n    to_field::<_, MOD_BITS>(Params::get_params(), self.limbs)\n    }\n\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits(_: Self) -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs(_: Self) -> u32 {\n        N\n    }\n\n    fn get_limbs_slice(self) -> [Field] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__mul::<_, MOD_BITS>(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__div::<_, MOD_BITS>(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod::<_, MOD_BITS>(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = Params::get_params();\n        let maybe_limbs = __tonelli_shanks_sqrt(params, self.limbs);\n        maybe_limbs.map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Add for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Sub for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Mul for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Div for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Eq for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/bignum.nr"}},"names":["bench_div_BN256"],"brillig_names":["__div","__compute_quadratic_expression_with_borrow_flags"]}