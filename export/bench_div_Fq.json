{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":5076893711634941794,"abi":{"parameters":[{"name":"a","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"b","type":{"kind":"struct","path":"bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":3,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"24":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"70":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/expressions.nr"},"71":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__div, __mul, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn to_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // let mut field: Field = 0;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    };\n    field_val \n    // assert that the conversion is possible, i.e. the bignum is less than grumpkin field modulus \n\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // safty: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n    // validate the limbs are in range and the value in total is less than 2^254\n\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    // validate that the last limb is less than the modulus\n    if N > 2 {\n        // validate that the result is less than the modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, 254>(grumpkin_modulus, result);\n        // validate that the limbs are in range\n        validate_in_range::<N, 254>(result);\n    }\n    // validate the limbs sum up to the field value\n    let field_val = if N < 2 {\n        result[0]\n    } else if N == 2 {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120\n    } else {\n        validate_in_range::<N, 254>(result);\n        result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n    };\n    assert(field_val == field);\n    result\n}\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let modulus = params.modulus;\n    for i in 0..N {\n        l *= two_pow_120;\n        r *= two_pow_120;\n        modulus_mod_n *= two_pow_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let mut diff = l - r;\n    let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let mut is_equal_modulus: bool = true;\n    let mut is_equal_zero: bool = true;\n    for i in 0..N {\n        is_equal_modulus = is_equal_modulus & (diff[i] == params.modulus[i]);\n        is_equal_zero = is_equal_zero & (diff[i] == 0);\n    }\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    let mut compare = val;\n    compare = p_minus_self;\n    validate_in_range::<_, MOD_BITS>(compare);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let result_limb = modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * borrow_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n            + (borrow_flags[i] as Field * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    let (result, carry_flags, borrow_flags, overflow_modulus) =\n        unsafe { __add_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut subtrahend: [Field; N] = [0; N];\n    if (overflow_modulus) {\n        subtrahend = modulus;\n    }\n    let result_limb = lhs[0] + rhs[0] - subtrahend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] + rhs[N - 1]\n        - subtrahend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags, underflow) =\n        unsafe { __sub_with_flags(params, lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n    let modulus = params.modulus;\n    let borrow_shift = 0x1000000000000000000000000000000;\n    let carry_shift = 0x1000000000000000000000000000000;\n\n    let mut addend: [Field; N] = [0; N];\n    if (underflow) {\n        addend = modulus;\n    }\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0]\n        + (borrow_flags[0] as Field * borrow_shift)\n        - (carry_flags[0] as Field * carry_shift);\n    assert(result_limb == 0);\n    for i in 1..N - 1 {\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - borrow_flags[i - 1] as Field\n            + carry_flags[i - 1] as Field\n            + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n        assert(result_limb == 0);\n    }\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n    result\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[lhs]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [result],\n        [true],\n    );\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    evaluate_quadratic_expression(\n        params,\n        [[result]],\n        [[false]],\n        [[rhs]],\n        [[false]],\n        [lhs],\n        [true],\n    );\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    // self / divisor = quotient rounded\n    // quotient * divisor + remainder - self = 0\n    evaluate_quadratic_expression(\n        params,\n        [[quotient]],\n        [[false]],\n        [[divisor]],\n        [[false]],\n        [numerator, remainder],\n        [true, false],\n    );\n    // we need (remainder < divisor)\n    // implies (divisor - remainder > 0)\n    validate_gt::<_, MOD_BITS>(divisor, remainder);\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor \n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/constrained_ops.nr"},"74":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..N {\n        let idx = N - 1 - i;\n        if (!__is_zero(x[idx])) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut result: [[Field; N]] = [[0; N]];\n    let mut temporaries: [[Field; N]; N] = std::mem::zeroed();\n    for i in 0..N {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n        result = result.push_back([0; N]);\n    }\n\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    let mut T0: [Field; N] = [0; N];\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (__is_zero(x[idx]) == false) {\n            T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_ops.nr"},"75":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            let idx = (i - 1) / 2;\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[idx] = carry as bool;\n            borrow_flags[idx] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            if (carry & borrow == 1) {\n                carry = 0;\n                borrow = 0;\n            }\n            carry_flags[i / 2] = carry as bool;\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quircky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/fns/unconstrained_helpers.nr"},"79":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/split_bits.nr"},"80":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::field_to_u60rep;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/utils/u60_representation.nr"},"85":{"source":"use crate::utils::u60_representation::U60Repr;\n\nuse crate::bignum::BigNum;\nuse crate::bignum::BigNumTrait;\n\nuse crate::params::BigNumParams;\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fields::bls12_381Fq::BLS12_381_Fq_Params;\nuse crate::fields::bn254Fq::BN254_Fq_Params;\nuse crate::fields::U256::U256Params;\n\n\n// the types we will be benchmarking \n\ntype Fq = BigNum<3, 254, BN254_Fq_Params>;\ntype BN256 = BigNum<3, 257, U256Params>;\ntype BN381 = BigNum<4, 381, BLS12_381_Fq_Params>;\n\n// macro magic to generate the benchmarks\nfn bench_add<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a + b;\n}\n\nfn bench_sub<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a - b;\n}\n\nfn bench_mul<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a * b;\n}\n\nfn bench_div<let N: u32, BN>(a: BN, b: BN)\nwhere\n    BN: BigNumTrait,\n{\n    let c = a / b;\n}\n\n\n// type Fq\n// type BN256\n// type BN381\n// type BN2048\n#[export]\nfn bench_add_Fq(a: Fq, b: Fq) {\n    bench_add::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_sub_Fq(a: Fq, b: Fq) {\n    bench_sub::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_mul_Fq(a: Fq, b: Fq) {\n    bench_mul::<3, Fq>(a, b);\n}\n\n#[export]\nfn bench_div_Fq(a: Fq, b: Fq) {\n    bench_div::<3, Fq>(a, b);\n}\n\n\n#[export]\nfn bench_add_BN256(a: BN256, b: BN256) {\n    bench_add::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_sub_BN256(a: BN256, b: BN256) {\n    bench_sub::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_mul_BN256(a: BN256, b: BN256) {\n        bench_mul::<3, BN256>(a, b);\n}\n\n#[export]\nfn bench_div_BN256(a: BN256, b: BN256) {\n    bench_div::<3, BN256>(a, b);\n}","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/benchmarks/bignum_benchmarks.nr"},"118":{"source":"use crate::utils::map::map;\n\nuse crate::params::BigNumParamsGetter;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, from_field, mul,\n        neg, sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range, to_field\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct BigNum<let N: u32, let MOD_BITS: u32, Params> {\n    pub limbs: [Field; N],\n}\n// We aim to avoid needing to add a generic parameter to this trait, for this reason we do not allow\n// accessing the limbs of the bignum except through slices.\npub trait BigNumTrait: Neg + Add + Sub + Mul + Div + Eq {\n    // TODO: this crashes the compiler? v0.32\n    // fn default() -> Self { std::default::Default::default  () }\n    pub fn new() -> Self;\n    pub fn one() -> Self;\n    pub fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    pub fn from_slice(limbs: [Field]) -> Self;\n    pub fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self;\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n    pub fn to_field(self) -> Field;\n\n    pub fn modulus() -> Self;\n    pub fn modulus_bits(self) -> u32;\n    pub fn num_limbs(self) -> u32;\n    pub fn get_limbs_slice(self) -> [Field];\n    pub fn get_limb(self, idx: u32) -> Field;\n    pub fn set_limb(&mut self, idx: u32, value: Field);\n\n    pub unconstrained fn __eq(self, other: Self) -> bool;\n    pub unconstrained fn __is_zero(self) -> bool;\n\n    pub unconstrained fn __neg(self) -> Self;\n    pub unconstrained fn __add(self, other: Self) -> Self;\n    pub unconstrained fn __sub(self, other: Self) -> Self;\n    pub unconstrained fn __mul(self, other: Self) -> Self;\n    pub unconstrained fn __div(self, other: Self) -> Self;\n    pub unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub unconstrained fn __invmod(self) -> Self;\n    pub unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    pub unconstrained fn __batch_invert<let M: u32>(to_invert: [Self; M]) -> [Self; M];\n    pub unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    pub unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    pub unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        add: [Self; ADD_N],\n        add_flags: [bool; ADD_N],\n    );\n\n    pub fn eq(self, other: Self) -> bool {\n        self == other\n    }\n    pub fn assert_is_not_equal(self, other: Self);\n    pub fn validate_in_range(self);\n    pub fn validate_in_field(self);\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    pub fn udiv(self, divisor: Self) -> Self;\n    pub fn umod(self, divisor: Self) -> Self;\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::convert::From<Field> for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn from(input: Field) -> Self {\n        let params = Params::get_params();\n        Self { limbs: from_field::<N, MOD_BITS>(params, input) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> Neg for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn neg(self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> BigNumTrait for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n\n    fn new() -> Self {\n        Self { limbs: [0; N] }\n    }\n\n    fn one() -> Self {\n        let mut result = BigNum::new();\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __derive_from_seed::<_, MOD_BITS, _>(params, seed) }\n    }\n\n    fn from_slice(limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array() }\n    }\n\n    pub fn to_field(self) -> Field {\n    to_field::<_, MOD_BITS>(Params::get_params(), self.limbs)\n    }\n\n\n    fn from_be_bytes<let NBytes: u32>(x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x) }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus() -> Self {\n        Self { limbs: Params::get_params().modulus }\n    }\n\n    fn modulus_bits(_: Self) -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs(_: Self) -> u32 {\n        N\n    }\n\n    fn get_limbs_slice(self) -> [Field] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    unconstrained fn __neg(self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__neg(params, self.limbs))\n    }\n\n    unconstrained fn __add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__add(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__sub(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__mul::<_, MOD_BITS>(params, self.limbs, other.limbs))\n    }\n\n    unconstrained fn __div(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self::from_slice(__div::<_, MOD_BITS>(params, self.limbs, divisor.limbs))\n    }\n\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let (q, r) = __udiv_mod(self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    unconstrained fn __invmod(self) -> Self {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        Self { limbs: __invmod::<_, MOD_BITS>(params, self.limbs) }\n    }\n\n    unconstrained fn __pow(self, exponent: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) }\n    }\n\n    unconstrained fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = Params::get_params();\n        assert(params.has_multiplicative_inverse);\n        __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn: Self| bn.limbs)).map(|limbs| {\n            Self { limbs }\n        })\n    }\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = Params::get_params();\n        let maybe_limbs = __tonelli_shanks_sqrt(params, self.limbs);\n        maybe_limbs.map(|limbs| Self { limbs })\n    }\n\n    unconstrained fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q_limbs, r_limbs) = __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        );\n        (Self { limbs: q_limbs }, Self { limbs: r_limbs })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        let params = Params::get_params();\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn: Self| bn.limbs)),\n            rhs_flags,\n            map(linear_terms, |bn: Self| bn.limbs),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = Params::get_params();\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = Params::get_params();\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = Params::get_params();\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q }, Self { limbs: r })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs) }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate) }\n    }\n}\n\n// impl<let N: u32, Params> BigNumTrait<N, Params> for BigNum<N, Params> where Params: BigNumParamsGetter<N> {}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Add for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Sub for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Mul for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::ops::Div for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, other: Self) -> Self {\n        let params = Params::get_params();\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, other.limbs) }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32, Params> std::cmp::Eq for BigNum<N, MOD_BITS, Params>\nwhere\n    Params: BigNumParamsGetter<N, MOD_BITS>,\n{\n    fn eq(self, other: Self) -> bool {\n        let params = Params::get_params();\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\n","path":"/Users/khashayarbarooti/aztec/noir-bignum/src/bignum.nr"}},"names":["bench_div_Fq"],"brillig_names":["__div","__compute_quadratic_expression_with_borrow_flags"]}